<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Google.OrTools</name>
    </assembly>
    <members>
        <member name="T:Google.OrTools.Algorithms.Int64Vector.Int64VectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Algorithms.Int64VectorVector.Int64VectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Algorithms.IntVector.IntVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Algorithms.IntVectorVector.IntVectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.LinearSolver.DoubleVector.DoubleVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.LinearSolver.Int64Vector.Int64VectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.LinearSolver.Int64VectorVector.Int64VectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.LinearSolver.IntVector.IntVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.LinearSolver.IntVectorVector.IntVectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.LinearSolver.MPConstraintVector.MPConstraintVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.LinearSolver.MPVariableVector.MPVariableVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.DecisionBuilderVector.DecisionBuilderVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.Int64Vector.Int64VectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.Int64VectorVector.Int64VectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.IntervalVarVector.IntervalVarVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.IntVarVector.IntVarVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.IntVector.IntVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.IntVectorVector.IntVectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchFilterVector.LocalSearchFilterVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchOperatorVector.LocalSearchOperatorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingEnumsReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/routing_enums.proto</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingEnumsReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/routing_enums.proto</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.FirstSolutionStrategy">
            <summary>
            First solution strategies, used as starting point of local search.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types">
            <summary>Container for nested types declared in the FirstSolutionStrategy message type.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Unset">
            <summary>
            See the homonymous value in LocalSearchMetaheuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Automatic">
            <summary>
            Lets the solver detect which strategy to use according to the model being
            solved.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.PathCheapestArc">
            <summary>
            --- Path addition heuristics ---
            Starting from a route "start" node, connect it to the node which produces
            the cheapest route segment, then extend the route by iterating on the
            last node added to the route.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.PathMostConstrainedArc">
            <summary>
            Same as PATH_CHEAPEST_ARC, but arcs are evaluated with a comparison-based
            selector which will favor the most constrained arc first. To assign a
            selector to the routing model, see
            RoutingModel::ArcIsMoreConstrainedThanArc() in routing.h for details.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.EvaluatorStrategy">
            <summary>
            Same as PATH_CHEAPEST_ARC, except that arc costs are evaluated using the
            function passed to RoutingModel::SetFirstSolutionEvaluator()
            (cf. routing.h).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Savings">
            <summary>
            Savings algorithm (Clarke &amp; Wright).
            Reference: Clarke, G. &amp; Wright, J.W.:
            "Scheduling of Vehicles from a Central Depot to a Number of Delivery
            Points", Operations Research, Vol. 12, 1964, pp. 568-581
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Sweep">
            <summary>
            Sweep algorithm (Wren &amp; Holliday).
            Reference: Anthony Wren &amp; Alan Holliday: Computer Scheduling of Vehicles
            from One or More Depots to a Number of Delivery Points Operational
            Research Quarterly (1970-1977),
            Vol. 23, No. 3 (Sep., 1972), pp. 333-344
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.Christofides">
            <summary>
            Christofides algorithm (actually a variant of the Christofides algorithm
            using a maximal matching instead of a maximum matching, which does
            not guarantee the 3/2 factor of the approximation on a metric travelling
            salesman). Works on generic vehicle routing models by extending a route
            until no nodes can be inserted on it.
            Reference: Nicos Christofides, Worst-case analysis of a new heuristic for
            the travelling salesman problem, Report 388, Graduate School of
            Industrial Administration, CMU, 1976.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.AllUnperformed">
            <summary>
            --- Path insertion heuristics ---
            Make all nodes inactive. Only finds a solution if nodes are optional (are
            element of a disjunction constraint with a finite penalty cost).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.BestInsertion">
            <summary>
            Iteratively build a solution by inserting the cheapest node at its
            cheapest position; the cost of insertion is based on the global cost
            function of the routing model. As of 2/2012, only works on models with
            optional nodes (with finite penalty costs).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.ParallelCheapestInsertion">
            <summary>
            Iteratively build a solution by inserting the cheapest node at its
            cheapest position; the cost of insertion is based on the arc cost
            function. Is faster than BEST_INSERTION.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.SequentialCheapestInsertion">
            <summary>
            Iteratively build a solution by constructing routes sequentially, for
            each route inserting the cheapest node at its cheapest position until the
            route is completed; the cost of insertion is based on the arc cost
            function. Is faster than PARALLEL_CHEAPEST_INSERTION.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.LocalCheapestInsertion">
            <summary>
            Iteratively build a solution by inserting each node at its cheapest
            position; the cost of insertion is based on the arc cost function.
            Differs from PARALLEL_CHEAPEST_INSERTION by the node selected for
            insertion; here nodes are considered in decreasing order of distance to
            the start/ends of the routes, i.e. farthest nodes are inserted first.
            Is faster than SEQUENTIAL_CHEAPEST_INSERTION.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.GlobalCheapestArc">
            <summary>
            --- Variable-based heuristics ---
            Iteratively connect two nodes which produce the cheapest route segment.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.LocalCheapestArc">
            <summary>
            Select the first node with an unbound successor and connect it to the
            node which produces the cheapest route segment.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.FirstSolutionStrategy.Types.Value.FirstUnboundMinValue">
            <summary>
            Select the first node with an unbound successor and connect it to the
            first available node.
            This is equivalent to the CHOOSE_FIRST_UNBOUND strategy combined with
            ASSIGN_MIN_VALUE (cf. constraint_solver.h).
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic">
            <summary>
            Local search metaheuristics used to guide the search. Apart from greedy
            descent, they will try to escape local minima.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types">
            <summary>Container for nested types declared in the LocalSearchMetaheuristic message type.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.Unset">
            <summary>
            Means "not set". If the solver sees that, it'll behave like for
            AUTOMATIC. But this value won't override others upon a proto MergeFrom(),
            whereas "AUTOMATIC" will.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.Automatic">
            <summary>
            Lets the solver select the metaheuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.GreedyDescent">
            <summary>
            Accepts improving (cost-reducing) local search neighbors until a local
            minimum is reached.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.GuidedLocalSearch">
            <summary>
            Uses guided local search to escape local minima
            (cf. http://en.wikipedia.org/wiki/Guided_Local_Search); this is generally
            the most efficient metaheuristic for vehicle routing.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.SimulatedAnnealing">
            <summary>
            Uses simulated annealing to escape local minima
            (cf. http://en.wikipedia.org/wiki/Simulated_annealing).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.TabuSearch">
            <summary>
            Uses tabu search to escape local minima
            (cf. http://en.wikipedia.org/wiki/Tabu_search).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.LocalSearchMetaheuristic.Types.Value.GenericTabuSearch">
            <summary>
            Uses tabu search on a list of variables to escape local minima. The list
            of variables to use must be provided via the SetTabuVarsCallback
            callback.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingParametersReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/routing_parameters.proto</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingParametersReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/routing_parameters.proto</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters">
             <summary>
             Parameters defining the search used to solve vehicle routing problems.
            
             If a parameter is unset (or, equivalently, set to its default value),
             then the routing library will pick its preferred value for that parameter
             automatically: this should be the case for most parameters.
             To see those "default" parameters, call GetDefaultRoutingSearchParameters().
             Next ID: 49
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.FirstSolutionStrategyFieldNumber">
            <summary>Field number for the "first_solution_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.FirstSolutionStrategy">
            <summary>
            First solution strategies, used as starting point of local search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseUnfilteredFirstSolutionStrategyFieldNumber">
            <summary>Field number for the "use_unfiltered_first_solution_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseUnfilteredFirstSolutionStrategy">
             <summary>
             --- Advanced first solutions strategy settings ---
             Don't touch these unless you know what you are doing.
            
             Use filtered version of first solution strategy if available.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsNeighborsRatioFieldNumber">
            <summary>Field number for the "savings_neighbors_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsNeighborsRatio">
            <summary>
            Parameters specific to the Savings first solution heuristic.
            Ratio (in ]0, 1]) of neighbors to consider for each node when constructing
            the savings. If unspecified, its value is considered to be 1.0.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsMaxMemoryUsageBytesFieldNumber">
            <summary>Field number for the "savings_max_memory_usage_bytes" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsMaxMemoryUsageBytes">
            <summary>
            The number of neighbors considered for each node in the Savings heuristic
            is chosen so that the space used to store the savings doesn't exceed
            savings_max_memory_usage_bytes, which must be in ]0, 1e10].
            NOTE: If both savings_neighbors_ratio and savings_max_memory_usage_bytes
            are specified, the number of neighbors considered for each node will be the
            minimum of the two numbers determined by these parameters.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsAddReverseArcsFieldNumber">
            <summary>Field number for the "savings_add_reverse_arcs" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsAddReverseArcs">
            <summary>
            Add savings related to reverse arcs when finding the nearest neighbors
            of the nodes.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsArcCoefficientFieldNumber">
            <summary>Field number for the "savings_arc_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsArcCoefficient">
            <summary>
            Coefficient of the cost of the arc for which the saving value is being
            computed:
            Saving(a-->b) = Cost(a-->end) + Cost(start-->b)
                            - savings_arc_coefficient * Cost(a-->b)
            This parameter must be greater than 0, and its default value is 1.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsParallelRoutesFieldNumber">
            <summary>Field number for the "savings_parallel_routes" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SavingsParallelRoutes">
            <summary>
            When true, the routes are built in parallel, sequentially otherwise.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFarthestSeedsRatioFieldNumber">
            <summary>Field number for the "cheapest_insertion_farthest_seeds_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFarthestSeedsRatio">
            <summary>
            Ratio (between 0 and 1) of available vehicles in the model on which
            farthest nodes of the model are inserted as seeds in the
            GlobalCheapestInsertion first solution heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionNeighborsRatioFieldNumber">
            <summary>Field number for the "cheapest_insertion_first_solution_neighbors_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionNeighborsRatio">
             <summary>
             Ratio (in ]0, 1]) of closest non start/end nodes to consider as neighbors
             for each node when creating new insertions in the parallel/sequential
             cheapest insertion heuristic.
             If not overridden, its default value is 1, meaning all neighbors will be
             considered.
             The neighborhood ratio is coupled with the corresponding min_neighbors
             integer, indicating the minimum number of neighbors to consider for each
             node:
             num_closest_neighbors =
                    max(min_neighbors, neighbors_ratio * NUM_NON_START_END_NODES)
             This minimum number of neighbors must be greater or equal to 1, its
             default value.
            
             Neighbors ratio and minimum number of neighbors for the first solution
             heuristic.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionMinNeighborsFieldNumber">
            <summary>Field number for the "cheapest_insertion_first_solution_min_neighbors" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionLsOperatorNeighborsRatioFieldNumber">
            <summary>Field number for the "cheapest_insertion_ls_operator_neighbors_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionLsOperatorNeighborsRatio">
            <summary>
            Neighbors ratio and minimum number of neighbors for the heuristic when used
            in a local search operator (see
            local_search_operators.use_global_cheapest_insertion_path_lns and
            local_search_operators.use_global_cheapest_insertion_chain_lns below).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionLsOperatorMinNeighborsFieldNumber">
            <summary>Field number for the "cheapest_insertion_ls_operator_min_neighbors" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionUseNeighborsRatioForInitializationFieldNumber">
            <summary>Field number for the "cheapest_insertion_first_solution_use_neighbors_ratio_for_initialization" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionFirstSolutionUseNeighborsRatioForInitialization">
            <summary>
            Whether or not to only consider closest neighbors when initializing the
            assignment for the first solution.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionAddUnperformedEntriesFieldNumber">
            <summary>Field number for the "cheapest_insertion_add_unperformed_entries" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.CheapestInsertionAddUnperformedEntries">
            <summary>
            Whether or not to consider entries making the nodes/pairs unperformed in
            the GlobalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ChristofidesUseMinimumMatchingFieldNumber">
            <summary>Field number for the "christofides_use_minimum_matching" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ChristofidesUseMinimumMatching">
            <summary>
            If true use minimum matching instead of minimal matching in the
            Christofides algorithm.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalSearchOperatorsFieldNumber">
            <summary>Field number for the "local_search_operators" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseMultiArmedBanditConcatenateOperatorsFieldNumber">
            <summary>Field number for the "use_multi_armed_bandit_concatenate_operators" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseMultiArmedBanditConcatenateOperators">
            <summary>
            If true, the solver will use multi-armed bandit concatenate operators. It
            dynamically chooses the next neighbor operator in order to get the best
            objective improvement.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MultiArmedBanditCompoundOperatorMemoryCoefficientFieldNumber">
            <summary>Field number for the "multi_armed_bandit_compound_operator_memory_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MultiArmedBanditCompoundOperatorMemoryCoefficient">
            <summary>
            Memory coefficient related to the multi-armed bandit compound operator.
            Sets how much the objective improvement of previous accepted neighbors
            influence the current average improvement.
            This parameter should be between 0 and 1.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MultiArmedBanditCompoundOperatorExplorationCoefficientFieldNumber">
            <summary>Field number for the "multi_armed_bandit_compound_operator_exploration_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MultiArmedBanditCompoundOperatorExplorationCoefficient">
            <summary>
            Positive parameter defining the exploration coefficient of the multi-armed
            bandit compound operator. Sets how often we explore rarely used and
            unsuccessful in the past operators
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.RelocateExpensiveChainNumArcsToConsiderFieldNumber">
            <summary>Field number for the "relocate_expensive_chain_num_arcs_to_consider" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.RelocateExpensiveChainNumArcsToConsider">
            <summary>
            Number of expensive arcs to consider cutting in the RelocateExpensiveChain
            neighborhood operator (see
            LocalSearchNeighborhoodOperators.use_relocate_expensive_chain()).
            This parameter must be greater than 2.
            NOTE(user): The number of neighbors generated by the operator for
            relocate_expensive_chain_num_arcs_to_consider = K is around
            K*(K-1)/2 * number_of_routes * number_of_nodes.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.HeuristicExpensiveChainLnsNumArcsToConsiderFieldNumber">
            <summary>Field number for the "heuristic_expensive_chain_lns_num_arcs_to_consider" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.HeuristicExpensiveChainLnsNumArcsToConsider">
            <summary>
            Number of expensive arcs to consider cutting in the
            FilteredHeuristicExpensiveChainLNSOperator operator.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.HeuristicCloseNodesLnsNumNodesFieldNumber">
            <summary>Field number for the "heuristic_close_nodes_lns_num_nodes" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.HeuristicCloseNodesLnsNumNodes">
            <summary>
            Number of closest nodes to consider for each node during the destruction
            phase of the FilteredHeuristicCloseNodesLNSOperator.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalSearchMetaheuristicFieldNumber">
            <summary>Field number for the "local_search_metaheuristic" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LocalSearchMetaheuristic">
            <summary>
            Local search metaheuristics used to guide the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.GuidedLocalSearchLambdaCoefficientFieldNumber">
            <summary>Field number for the "guided_local_search_lambda_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.GuidedLocalSearchLambdaCoefficient">
            <summary>
            These are advanced settings which should not be modified unless you know
            what you are doing.
            Lambda coefficient used to penalize arc costs when GUIDED_LOCAL_SEARCH is
            used. Must be positive.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseDepthFirstSearchFieldNumber">
            <summary>Field number for the "use_depth_first_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseDepthFirstSearch">
             <summary>
             --- Search control ---
            
             If true, the solver should use depth-first search rather than local search
             to solve the problem.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseCpFieldNumber">
            <summary>Field number for the "use_cp" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseCp">
            <summary>
            If true, use the CP solver to find a solution. Either local or depth-first
            search will be used depending on the value of use_depth_first_search. Will
            be run before the CP-SAT solver (cf. use_cp_sat).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseCpSatFieldNumber">
            <summary>Field number for the "use_cp_sat" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseCpSat">
            <summary>
            If true, use the CP-SAT solver to find a solution. If use_cp is also true,
            the CP-SAT solver will be run after the CP solver if there is time
            remaining and will use the CP solution as a hint for the CP-SAT search.
            As of 5/2019, only TSP models can be solved.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseGeneralizedCpSatFieldNumber">
            <summary>Field number for the "use_generalized_cp_sat" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseGeneralizedCpSat">
            <summary>
            If true, use the CP-SAT solver to find a solution on generalized routing
            model. If use_cp is also true, the CP-SAT solver will be run after the CP
            solver if there is time remaining and will use the CP solution as a hint
            for the CP-SAT search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SatParametersFieldNumber">
            <summary>Field number for the "sat_parameters" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SatParameters">
            <summary>
            If use_cp_sat or use_generalized_cp_sat is true, contains the SAT algorithm
            parameters which will be used.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ContinuousSchedulingSolverFieldNumber">
            <summary>Field number for the "continuous_scheduling_solver" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.MixedIntegerSchedulingSolverFieldNumber">
            <summary>Field number for the "mixed_integer_scheduling_solver" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.OptimizationStepFieldNumber">
            <summary>Field number for the "optimization_step" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.OptimizationStep">
            <summary>
            Minimum step by which the solution must be improved in local search. 0
            means "unspecified". If this value is fractional, it will get rounded to
            the nearest integer.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.NumberOfSolutionsToCollectFieldNumber">
            <summary>Field number for the "number_of_solutions_to_collect" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.NumberOfSolutionsToCollect">
            <summary>
            Number of solutions to collect during the search. Corresponds to the best
            solutions found during the search. 0 means "unspecified".
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SolutionLimitFieldNumber">
            <summary>Field number for the "solution_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.SolutionLimit">
            <summary>
            -- Search limits --
            Limit to the number of solutions generated during the search. 0 means
            "unspecified".
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.TimeLimitFieldNumber">
            <summary>Field number for the "time_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.TimeLimit">
            <summary>
            Limit to the time spent in the search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LnsTimeLimitFieldNumber">
            <summary>Field number for the "lns_time_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LnsTimeLimit">
            <summary>
            Limit to the time spent in the completion search for each local search
            neighbor.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ImprovementLimitParametersFieldNumber">
            <summary>Field number for the "improvement_limit_parameters" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.ImprovementLimitParameters">
            <summary>
            The improvement search limit is added to the solver if the following
            parameters are set.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseFullPropagationFieldNumber">
            <summary>Field number for the "use_full_propagation" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.UseFullPropagation">
             <summary>
             --- Propagation control ---
             These are advanced settings which should not be modified unless you know
             what you are doing.
            
             Use constraints with full propagation in routing model (instead of 'light'
             propagation only). Full propagation is only necessary when using
             depth-first search or for models which require strong propagation to
             finalize the value of secondary variables.
             Changing this setting to true will slow down the search in most cases and
             increase memory consumption in all cases.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogSearchFieldNumber">
            <summary>Field number for the "log_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogSearch">
             <summary>
             --- Miscellaneous ---
             Some of these are advanced settings which should not be modified unless you
             know what you are doing.
            
             Activates search logging. For each solution found during the search, the
             following will be displayed: its objective value, the maximum objective
             value since the beginning of the search, the elapsed time since the
             beginning of the search, the number of branches explored in the search
             tree, the number of failures in the search tree, the depth of the search
             tree, the number of local search neighbors explored, the number of local
             search neighbors filtered by local search filters, the number of local
             search neighbors accepted, the total memory used and the percentage of the
             search done.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogCostScalingFactorFieldNumber">
            <summary>Field number for the "log_cost_scaling_factor" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogCostScalingFactor">
            <summary>
            In logs, cost values will be scaled and offset by the given values in the
            following way: log_cost_scaling_factor * (cost + log_cost_offset)
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogCostOffsetFieldNumber">
            <summary>Field number for the "log_cost_offset" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogTagFieldNumber">
            <summary>Field number for the "log_tag" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.LogTag">
            <summary>
            In logs, this tag will be appended to each line corresponding to a new
            solution. Useful to sort out logs when several solves are run in parallel.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types">
            <summary>Container for nested types declared in the RoutingSearchParameters message type.</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.SchedulingSolver">
            <summary>
            Underlying solver to use in dimension scheduling, respectively for
            continuous and mixed models.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators">
            <summary>
            Local search neighborhood operators used to build a solutions neighborhood.
            Next ID: 34
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateFieldNumber">
            <summary>Field number for the "use_relocate" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocate">
            <summary>
            --- Inter-route operators ---
            Operator which moves a single node to another position.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5
            (where (1, 5) are first and last nodes of the path and can therefore not
            be moved):
              1 ->  3  -> [2] ->  4  -> 5
              1 ->  3  ->  4  -> [2] -> 5
              1 ->  2  ->  4  -> [3] -> 5
              1 -> [4] ->  2  ->  3  -> 5
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocatePairFieldNumber">
            <summary>Field number for the "use_relocate_pair" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocatePair">
            <summary>
            Operator which moves a pair of pickup and delivery nodes to another
            position where the first node of the pair must be before the second node
            on the same path. Compared to the light_relocate_pair operator, tries all
            possible positions of insertion of a pair (not only after another pair).
            Possible neighbors for the path 1 -> A -> B -> 2 -> 3 (where (1, 3) are
            first and last nodes of the path and can therefore not be moved, and
            (A, B) is a pair of nodes):
              1 -> [A] ->  2  -> [B] -> 3
              1 ->  2  -> [A] -> [B] -> 3
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLightRelocatePairFieldNumber">
            <summary>Field number for the "use_light_relocate_pair" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLightRelocatePair">
            <summary>
            Operator which moves a pair of pickup and delivery nodes after another
            pair.
            Possible neighbors for paths 1 -> A -> B -> 2, 3 -> C -> D -> 4 (where
            (1, 2) and (3, 4) are first and last nodes of paths and can therefore not
            be moved, and (A, B) and (C, D) are pair of nodes):
              1 -> 2, 3 -> C -> [A] -> D -> [B] -> 4
              1 -> A -> [C] -> B -> [D] -> 2, 3 -> 4
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateNeighborsFieldNumber">
            <summary>Field number for the "use_relocate_neighbors" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateNeighbors">
            <summary>
            Relocate neighborhood which moves chains of neighbors.
            The operator starts by relocating a node n after a node m, then continues
            moving nodes which were after n as long as the "cost" added is less than
            the "cost" of the arc (m, n). If the new chain doesn't respect the domain
            of next variables, it will try reordering the nodes until it finds a
            valid path.
            Possible neighbors for path 1 -> A -> B -> C -> D -> E -> 2 (where (1, 2)
            are first and last nodes of the path and can therefore not be moved, A
            must be performed before B, and A, D and E are located at the same
            place):
            1 -> A -> C -> [B] -> D -> E -> 2
            1 -> A -> C -> D -> [B] -> E -> 2
            1 -> A -> C -> D -> E -> [B] -> 2
            1 -> A -> B -> D -> [C] -> E -> 2
            1 -> A -> B -> D -> E -> [C] -> 2
            1 -> A -> [D] -> [E] -> B -> C -> 2
            1 -> A -> B -> [D] -> [E] ->  C -> 2
            1 -> A -> [E] -> B -> C -> D -> 2
            1 -> A -> B -> [E] -> C -> D -> 2
            1 -> A -> B -> C -> [E] -> D -> 2
            This operator is extremelly useful to move chains of nodes which are
            located at the same place (for instance nodes part of a same stop).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateSubtripFieldNumber">
            <summary>Field number for the "use_relocate_subtrip" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateSubtrip">
             <summary>
             Relocate neighborhood that moves subpaths all pickup and delivery
             pairs have both pickup and delivery inside the subpath or both outside
             the subpath. For instance, for given paths:
             0 -> A -> B -> A' -> B' -> 5 -> 6 -> 8
             7 -> 9
             Pairs (A,A') and (B,B') are interleaved, so the expected neighbors are:
             0 -> 5 -> A -> B -> A' -> B' -> 6 -> 8
             7 -> 9
            
             0 -> 5 -> 6 -> A -> B -> A' -> B' -> 8
             7 -> 9
            
             0 -> 5 -> 6 -> 8
             7 -> A -> B -> A' -> B' -> 9
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangeFieldNumber">
            <summary>Field number for the "use_exchange" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchange">
            <summary>
            Operator which exchanges the positions of two nodes.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5
            (where (1, 5) are first and last nodes of the path and can therefore not
            be moved):
              1 -> [3] -> [2] ->  4  -> 5
              1 -> [4] ->  3  -> [2] -> 5
              1 ->  2  -> [4] -> [3] -> 5
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangePairFieldNumber">
            <summary>Field number for the "use_exchange_pair" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangePair">
            <summary>
            Operator which exchanges the positions of two pair of nodes. Pairs
            correspond to the pickup and delivery pairs defined in the routing model.
            Possible neighbor for the paths
            1 -> A -> B -> 2 -> 3 and 4 -> C -> D -> 5
            (where (1, 3) and (4, 5) are first and last nodes of the paths and can
            therefore not be moved, and (A, B) and (C,D) are pairs of nodes):
              1 -> [C] ->  [D] -> 2 -> 3, 4 -> [A] -> [B] -> 5
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangeSubtripFieldNumber">
            <summary>Field number for the "use_exchange_subtrip" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExchangeSubtrip">
            <summary>
            Operator which exchanges subtrips associated to two pairs of nodes,
            see use_relocate_subtrip for a definition of subtrips.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseCrossFieldNumber">
            <summary>Field number for the "use_cross" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseCross">
            <summary>
            Operator which cross exchanges the starting chains of 2 paths, including
            exchanging the whole paths.
            First and last nodes are not moved.
            Possible neighbors for the paths 1 -> 2 -> 3 -> 4 -> 5 and 6 -> 7 -> 8
            (where (1, 5) and (6, 8) are first and last nodes of the paths and can
            therefore not be moved):
              1 -> [7] -> 3 -> 4 -> 5  6 -> [2] -> 8
              1 -> [7] -> 4 -> 5       6 -> [2 -> 3] -> 8
              1 -> [7] -> 5            6 -> [2 -> 3 -> 4] -> 8
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseCrossExchangeFieldNumber">
            <summary>Field number for the "use_cross_exchange" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseCrossExchange">
            <summary>
            Not implemented yet. TODO(b/68128619): Implement.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateExpensiveChainFieldNumber">
            <summary>Field number for the "use_relocate_expensive_chain" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateExpensiveChain">
            <summary>
            Operator which detects the relocate_expensive_chain_num_arcs_to_consider
            most expensive arcs on a path, and moves the chain resulting from cutting
            pairs of arcs among these to another position.
            Possible neighbors for paths 1 -> 2 (empty) and
            3 -> A ------> B --> C -----> D -> 4 (where A -> B and C -> D are the 2
            most expensive arcs, and the chain resulting from breaking them is
            B -> C):
              1 -> [B -> C] -> 2     3 -> A -> D -> 4
              1 -> 2      3 -> [B -> C] -> A -> D -> 4
              1 -> 2      3 -> A -> D -> [B -> C] -> 4
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTwoOptFieldNumber">
            <summary>Field number for the "use_two_opt" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTwoOpt">
            <summary>
            --- Intra-route operators ---
            Operator which reverves a sub-chain of a path. It is called TwoOpt
            because it breaks two arcs on the path; resulting paths are called
            two-optimal.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5
            (where (1, 5) are first and last nodes of the path and can therefore not
            be moved):
              1 -> [3 -> 2] -> 4  -> 5
              1 -> [4 -> 3  -> 2] -> 5
              1 ->  2 -> [4 -> 3] -> 5
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseOrOptFieldNumber">
            <summary>Field number for the "use_or_opt" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseOrOpt">
            <summary>
            Operator which moves sub-chains of a path of length 1, 2 and 3 to another
            position in the same path.
            When the length of the sub-chain is 1, the operator simply moves a node
            to another position.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5, for a sub-chain
            length of 2 (where (1, 5) are first and last nodes of the path and can
            therefore not be moved):
              1 ->  4 -> [2 -> 3] -> 5
              1 -> [3 -> 4] -> 2  -> 5
            The OR_OPT operator is a limited version of 3-Opt (breaks 3 arcs on a
            path).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLinKernighanFieldNumber">
            <summary>Field number for the "use_lin_kernighan" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLinKernighan">
            <summary>
            Lin-Kernighan operator.
            While the accumulated local gain is positive, performs a 2-OPT or a 3-OPT
            move followed by a series of 2-OPT moves. Returns a neighbor for which
            the global gain is positive.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTspOptFieldNumber">
            <summary>Field number for the "use_tsp_opt" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTspOpt">
            <summary>
            Sliding TSP operator.
            Uses an exact dynamic programming algorithm to solve the TSP
            corresponding to path sub-chains.
            For a subchain 1 -> 2 -> 3 -> 4 -> 5 -> 6, solves the TSP on
            nodes A, 2, 3, 4, 5, where A is a merger of nodes 1 and 6 such that
            cost(A,i) = cost(1,i) and cost(i,A) = cost(i,6).
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeActiveFieldNumber">
            <summary>Field number for the "use_make_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeActive">
            <summary>
            --- Operators on inactive nodes ---
            Operator which inserts an inactive node into a path.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
            (where 1 and 4 are first and last nodes of the path) are:
              1 -> [5] ->  2  ->  3  -> 4
              1 ->  2  -> [5] ->  3  -> 4
              1 ->  2  ->  3  -> [5] -> 4
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateAndMakeActiveFieldNumber">
            <summary>Field number for the "use_relocate_and_make_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocateAndMakeActive">
            <summary>
            Operator which relocates a node while making an inactive one active.
            As of 3/2017, the operator is limited to two kinds of moves:
            - Relocating a node and replacing it by an inactive node.
              Possible neighbor for path 1 -> 5, 2 -> 3 -> 6 and 4 inactive
              (where 1,2 and 5,6 are first and last nodes of paths) is:
              1 -> 3 -> 5, 2 -> 4 -> 6.
            - Relocating a node and inserting an inactive node next to it.
              Possible neighbor for path 1 -> 5, 2 -> 3 -> 6 and 4 inactive
              (where 1,2 and 5,6 are first and last nodes of paths) is:
              1 -> 4 -> 3 -> 5, 2 -> 6.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeInactiveFieldNumber">
            <summary>Field number for the "use_make_inactive" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeInactive">
            <summary>
            Operator which makes path nodes inactive.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 (where 1 and 4 are first
            and last nodes of the path) are:
              1 -> 3 -> 4 with 2 inactive
              1 -> 2 -> 4 with 3 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeChainInactiveFieldNumber">
            <summary>Field number for the "use_make_chain_inactive" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseMakeChainInactive">
            <summary>
            Operator which makes a "chain" of path nodes inactive.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 (where 1 and 4 are first
            and last nodes of the path) are:
              1 -> 3 -> 4 with 2 inactive
              1 -> 2 -> 4 with 3 inactive
              1 -> 4 with 2 and 3 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseSwapActiveFieldNumber">
            <summary>Field number for the "use_swap_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseSwapActive">
            <summary>
            Operator which replaces an active node by an inactive one.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
            (where 1 and 4 are first and last nodes of the path) are:
              1 -> [5] ->  3  -> 4 with 2 inactive
              1 ->  2  -> [5] -> 4 with 3 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExtendedSwapActiveFieldNumber">
            <summary>Field number for the "use_extended_swap_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseExtendedSwapActive">
            <summary>
            Operator which makes an inactive node active and an active one inactive.
            It is similar to SwapActiveOperator excepts that it tries to insert the
            inactive node in all possible positions instead of just the position of
            the node made inactive.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
            (where 1 and 4 are first and last nodes of the path) are:
              1 -> [5] ->  3  -> 4 with 2 inactive
              1 ->  3  -> [5] -> 4 with 2 inactive
              1 -> [5] ->  2  -> 4 with 3 inactive
              1 ->  2  -> [5] -> 4 with 3 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseNodePairSwapActiveFieldNumber">
            <summary>Field number for the "use_node_pair_swap_active" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseNodePairSwapActive">
            <summary>
            Operator which makes an inactive node active and an active pair of nodes
            inactive OR makes an inactive pair of nodes active and an active node
            inactive.
            Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
            (where 1 and 4 are first and last nodes of the path and (2,3) is a pair
            of nodes) are:
              1 -> [5] -> 4 with (2,3) inactive
            Possible neighbors for the path 1 -> 2 -> 3 with (4,5) inactive
            (where 1 and 3 are first and last nodes of the path and (4,5) is a pair
            of nodes) are:
              1 -> [4] -> [5] -> 3 with 2 inactive
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UsePathLnsFieldNumber">
            <summary>Field number for the "use_path_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UsePathLns">
            <summary>
            --- Large neighborhood search operators ---
            Operator which relaxes two sub-chains of three consecutive arcs each.
            Each sub-chain is defined by a start node and the next three arcs. Those
            six arcs are relaxed to build a new neighbor.
            PATH_LNS explores all possible pairs of starting nodes and so defines
            n^2 neighbors, n being the number of nodes.
            Note that the two sub-chains can be part of the same path; they even may
            overlap.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseFullPathLnsFieldNumber">
            <summary>Field number for the "use_full_path_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseFullPathLns">
            <summary>
            Operator which relaxes one entire path and all unactive nodes.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTspLnsFieldNumber">
            <summary>Field number for the "use_tsp_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseTspLns">
            <summary>
            TSP-base LNS.
            Randomly merges consecutive nodes until n "meta"-nodes remain and solves
            the corresponding TSP.
            This defines an "unlimited" neighborhood which must be stopped by search
            limits. To force diversification, the operator iteratively forces each
            node to serve as base of a meta-node.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseInactiveLnsFieldNumber">
            <summary>Field number for the "use_inactive_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseInactiveLns">
            <summary>
            Operator which relaxes all inactive nodes and one sub-chain of six
            consecutive arcs. That way the path can be improved by inserting inactive
            nodes or swaping arcs.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionPathLnsFieldNumber">
            <summary>Field number for the "use_global_cheapest_insertion_path_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionPathLns">
            <summary>
            --- LNS-like large neighborhood search operators using heuristics ---
            Operator which makes all nodes on a route unperformed, and reinserts them
            using the GlobalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionPathLnsFieldNumber">
            <summary>Field number for the "use_local_cheapest_insertion_path_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionPathLns">
            <summary>
            Same as above but using LocalCheapestInsertion as a heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocatePathGlobalCheapestInsertionInsertUnperformedFieldNumber">
            <summary>Field number for the "use_relocate_path_global_cheapest_insertion_insert_unperformed" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseRelocatePathGlobalCheapestInsertionInsertUnperformed">
            <summary>
            The following operator relocates an entire route to an empty path and
            then tries to insert the unperformed nodes using the global cheapest
            insertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionExpensiveChainLnsFieldNumber">
            <summary>Field number for the "use_global_cheapest_insertion_expensive_chain_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionExpensiveChainLns">
            <summary>
            This operator finds heuristic_expensive_chain_lns_num_arcs_to_consider
            most expensive arcs on a route, makes the nodes in between pairs of these
            expensive arcs unperformed, and reinserts them using the
            GlobalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionExpensiveChainLnsFieldNumber">
            <summary>Field number for the "use_local_cheapest_insertion_expensive_chain_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionExpensiveChainLns">
            <summary>
            Same as above but using LocalCheapestInsertion as a heuristic for
            insertion.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionCloseNodesLnsFieldNumber">
            <summary>Field number for the "use_global_cheapest_insertion_close_nodes_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseGlobalCheapestInsertionCloseNodesLns">
            <summary>
            The following operator makes a node and its
            heuristic_close_nodes_lns_num_nodes closest neighbors unperformed along
            with each of their corresponding performed pickup/delivery pairs, and
            then reinserts them using the GlobalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionCloseNodesLnsFieldNumber">
            <summary>Field number for the "use_local_cheapest_insertion_close_nodes_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.LocalSearchNeighborhoodOperators.UseLocalCheapestInsertionCloseNodesLns">
            <summary>
            Same as above, but insertion positions for nodes are determined by the
            LocalCheapestInsertion heuristic.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters">
            <summary>
            Parameters required for the improvement search limit.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters.ImprovementRateCoefficientFieldNumber">
            <summary>Field number for the "improvement_rate_coefficient" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters.ImprovementRateCoefficient">
            <summary>
            Parameter that regulates exchange rate between objective improvement and
            number of neighbors spent. The smaller the value, the sooner the limit
            stops the search. Must be positive.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters.ImprovementRateSolutionsDistanceFieldNumber">
            <summary>Field number for the "improvement_rate_solutions_distance" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingSearchParameters.Types.ImprovementSearchLimitParameters.ImprovementRateSolutionsDistance">
            <summary>
            Parameter that specifies the distance between improvements taken into
            consideration for calculating the improvement rate.
            Example: For 5 objective improvements = (10, 8, 6, 4, 2), and the
            solutions_distance parameter of 2, then the improvement_rate will be
            computed for (10, 6), (8, 4), and (6, 2).
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RoutingModelParameters">
            <summary>
            Parameters which have to be set when creating a RoutingModel.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingModelParameters.SolverParametersFieldNumber">
            <summary>Field number for the "solver_parameters" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingModelParameters.SolverParameters">
            <summary>
            Parameters to use in the underlying constraint solver.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingModelParameters.ReduceVehicleCostModelFieldNumber">
            <summary>Field number for the "reduce_vehicle_cost_model" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingModelParameters.ReduceVehicleCostModel">
            <summary>
            Advanced settings.
            If set to true reduction of the underlying constraint model will be
            attempted when all vehicles have exactly the same cost structure. This can
            result in significant speedups.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RoutingModelParameters.MaxCallbackCacheSizeFieldNumber">
            <summary>Field number for the "max_callback_cache_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RoutingModelParameters.MaxCallbackCacheSize">
            <summary>
            Cache callback calls if the number of nodes in the model is less or equal
            to this value.
            </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SearchLimitReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/search_limit.proto</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.SearchLimitReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/search_limit.proto</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.RegularLimitParameters">
            <summary>
            A search limit
            The default values for int64 fields is the maxima value, i.e., 2^63-1
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.TimeFieldNumber">
            <summary>Field number for the "time" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.RegularLimitParameters.Time">
            <summary>
            TODO(user): Specify the time units or switch to google.Duration proto.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.BranchesFieldNumber">
            <summary>Field number for the "branches" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.FailuresFieldNumber">
            <summary>Field number for the "failures" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.SolutionsFieldNumber">
            <summary>Field number for the "solutions" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.SmartTimeCheckFieldNumber">
            <summary>Field number for the "smart_time_check" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.RegularLimitParameters.CumulativeFieldNumber">
            <summary>Field number for the "cumulative" field.</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SearchMonitorVector.SearchMonitorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SequenceVarVector.SequenceVarVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SolverParametersReflection">
            <summary>Holder for reflection information generated from ortools/constraint_solver/solver_parameters.proto</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.SolverParametersReflection.Descriptor">
            <summary>File descriptor for ortools/constraint_solver/solver_parameters.proto</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.ConstraintSolverParameters">
            <summary>
            Solver parameters.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.CompressTrailFieldNumber">
            <summary>Field number for the "compress_trail" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.CompressTrail">
            <summary>
            This parameter indicates if the solver should compress the trail
            during the search. No compression means that the solver will be faster,
            but will use more memory.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TrailBlockSizeFieldNumber">
            <summary>Field number for the "trail_block_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TrailBlockSize">
            <summary>
            This parameter indicates the default size of a block of the trail.
            Compression applies at the block level.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ArraySplitSizeFieldNumber">
            <summary>Field number for the "array_split_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ArraySplitSize">
            <summary>
            When a sum/min/max operation is applied on a large array, this
            array is recursively split into blocks of size 'array_split_size'.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.StoreNamesFieldNumber">
            <summary>Field number for the "store_names" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.StoreNames">
            <summary>
            This parameters indicates if the solver should store the names of
            the objets it manages.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.NameCastVariablesFieldNumber">
            <summary>Field number for the "name_cast_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.NameCastVariables">
            <summary>
            Create names for cast variables.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.NameAllVariablesFieldNumber">
            <summary>Field number for the "name_all_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.NameAllVariables">
            <summary>
            Should anonymous variables be given a name.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfilePropagationFieldNumber">
            <summary>Field number for the "profile_propagation" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfilePropagation">
            <summary>
            Activate propagation profiling.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfileFileFieldNumber">
            <summary>Field number for the "profile_file" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfileFile">
            <summary>
            Export propagation profiling data to file.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfileLocalSearchFieldNumber">
            <summary>Field number for the "profile_local_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.ProfileLocalSearch">
            <summary>
            Activate local search profiling.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintLocalSearchProfileFieldNumber">
            <summary>Field number for the "print_local_search_profile" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintLocalSearchProfile">
            <summary>
            Print local search profiling data after solving.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TracePropagationFieldNumber">
            <summary>Field number for the "trace_propagation" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TracePropagation">
            <summary>
            Activate propagate tracing.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TraceSearchFieldNumber">
            <summary>Field number for the "trace_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.TraceSearch">
            <summary>
            Trace search.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintModelFieldNumber">
            <summary>Field number for the "print_model" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintModel">
            <summary>
            Print the model before solving.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintModelStatsFieldNumber">
            <summary>Field number for the "print_model_stats" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintModelStats">
            <summary>
            Print model statistics before solving.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintAddedConstraintsFieldNumber">
            <summary>Field number for the "print_added_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.PrintAddedConstraints">
            <summary>
            Print added constraints.
            </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.DisableSolveFieldNumber">
            <summary>Field number for the "disable_solve" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseSmallTableFieldNumber">
            <summary>Field number for the "use_small_table" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseSmallTable">
             <summary>
            
             Control the implementation of the table constraint.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseCumulativeEdgeFinderFieldNumber">
            <summary>Field number for the "use_cumulative_edge_finder" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseCumulativeEdgeFinder">
             <summary>
            
             Control the propagation of the cumulative constraint.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseCumulativeTimeTableFieldNumber">
            <summary>Field number for the "use_cumulative_time_table" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseCumulativeTimeTableSyncFieldNumber">
            <summary>Field number for the "use_cumulative_time_table_sync" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseSequenceHighDemandTasksFieldNumber">
            <summary>Field number for the "use_sequence_high_demand_tasks" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseAllPossibleDisjunctionsFieldNumber">
            <summary>Field number for the "use_all_possible_disjunctions" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.MaxEdgeFinderSizeFieldNumber">
            <summary>Field number for the "max_edge_finder_size" field.</summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.DiffnUseCumulativeFieldNumber">
            <summary>Field number for the "diffn_use_cumulative" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.DiffnUseCumulative">
             <summary>
            
             Control the propagation of the diffn constraint.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseElementRmqFieldNumber">
            <summary>Field number for the "use_element_rmq" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.UseElementRmq">
             <summary>
            
             Control the implementation of the element constraint.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.SkipLocallyOptimalPathsFieldNumber">
            <summary>Field number for the "skip_locally_optimal_paths" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.SkipLocallyOptimalPaths">
             <summary>
            
             Skip locally optimal pairs of paths in PathOperators. Setting this
             parameter to true might skip valid neighbors if there are constraints
             linking paths together (such as precedences). In any other case this
             should only speed up the search without omitting any neighbors.
             </summary>
        </member>
        <member name="F:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.CheckSolutionPeriodFieldNumber">
            <summary>Field number for the "check_solution_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.CheckSolutionPeriod">
             <summary>
            
             Control the behavior of local search.
             </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.Types">
            <summary>Container for nested types declared in the ConstraintSolverParameters message type.</summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.ConstraintSolverParameters.Types.TrailCompression">
             <summary>
            
             Internal parameters of the solver.
             </summary>
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.SymmetryBreakerVector.SymmetryBreakerVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.NetDecisionBuilder">
             This class acts as a intermediate step between a c++ decision builder and a
             .Net one. Its main purpose is to catch the .Net application exception
             launched when a failure occurs during the Next() call, and to return
             silently a System.ApplicationException that will propagate the failure back
             to the C++ code.
            
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecisionBuilder.NextWrapper(Google.OrTools.ConstraintSolver.Solver)">
            This methods wraps the calls to next() and catches fail exceptions.
            It currently catches all application exceptions.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecisionBuilder.Next(Google.OrTools.ConstraintSolver.Solver)">
            This is the new method to subclass when defining a .Net decision builder.
        </member>
        <member name="T:Google.OrTools.ConstraintSolver.NetDecision">
             This class acts as a intermediate step between a c++ decision and a
             .Net one. Its main purpose is to catch the .Net application
             exception launched when a failure occurs during the
             Apply()/Refute() calls, and to set the ShouldFail() flag on the
             solver that will propagate the failure back to the C++ code.
            
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecision.ApplyWrapper(Google.OrTools.ConstraintSolver.Solver)">
            This methods wraps the calls to Apply() and catches fail exceptions.
            It currently catches all application exceptions.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecision.Apply(Google.OrTools.ConstraintSolver.Solver)">
            This is a new method to subclass when defining a .Net decision.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDecision.Refute(Google.OrTools.ConstraintSolver.Solver)">
            This is a new method to subclass when defining a .Net decision.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDemon.RunWrapper(Google.OrTools.ConstraintSolver.Solver)">
            This methods wraps the calls to next() and catches fail exceptions.
        </member>
        <member name="M:Google.OrTools.ConstraintSolver.NetDemon.Run(Google.OrTools.ConstraintSolver.Solver)">
            This is the new method to subclass when defining a .Net decision builder.
        </member>
        <member name="T:Google.OrTools.Sat.CpModelReflection">
            <summary>Holder for reflection information generated from ortools/sat/cp_model.proto</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelReflection.Descriptor">
            <summary>File descriptor for ortools/sat/cp_model.proto</summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpSolverStatus">
            <summary>
            The status returned by a solver trying to solve a CpModelProto.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.Unknown">
            <summary>
            The status of the model is still unknown. A search limit has been reached
            before any of the statuses below could be determined.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.ModelInvalid">
            <summary>
            The given CpModelProto didn't pass the validation step. You can get a
            detailed error by calling ValidateCpModel(model_proto).
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.Feasible">
            <summary>
            A feasible solution has been found. But the search was stopped before we
            could prove optimality or before we enumerated all solutions of a
            feasibility problem (if asked).
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.Infeasible">
            <summary>
            The problem has been proven infeasible.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverStatus.Optimal">
             <summary>
             An optimal feasible solution has been found.
            
             More generally, this status represent a success. So we also return OPTIMAL
             if we find a solution for a pure feasiblity problem or if a gap limit has
             been specified and we return a solution within this limit. In the case
             where we need to return all the feasible solution, this status will only be
             returned if we enumerated all of them; If we stopped before, we will return
             FEASIBLE.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.IntegerVariableProto">
             <summary>
             An integer variable.
            
             It will be referred to by an int32 corresponding to its index in a
             CpModelProto variables field.
            
             Depending on the context, a reference to a variable whose domain is in [0, 1]
             can also be seen as a Boolean that will be true if the variable value is 1
             and false if it is 0. When used in this context, the field name will always
             contain the word "literal".
            
             Negative reference (advanced usage): to simplify the creation of a model and
             for efficiency reasons, all the "literal" or "variable" fields can also
             contain a negative index. A negative index i will refer to the negation of
             the integer variable at index -i -1 or to NOT the literal at the same index.
            
             Ex: A variable index 4 will refer to the integer variable model.variables(4)
             and an index of -5 will refer to the negation of the same variable. A literal
             index 4 will refer to the logical fact that model.variable(4) == 1 and a
             literal index of -5 will refer to the logical fact model.variable(4) == 0.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntegerVariableProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.IntegerVariableProto.Name">
            <summary>
            For debug/logging only. Can be empty.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntegerVariableProto.DomainFieldNumber">
            <summary>Field number for the "domain" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.IntegerVariableProto.Domain">
             <summary>
             The variable domain given as a sorted list of n disjoint intervals
             [min, max] and encoded as [min_0, max_0,  ..., min_{n-1}, max_{n-1}].
            
             The most common example being just [min, max].
             If min == max, then this is a constant variable.
            
             We have:
              - domain_size() is always even.
              - min == domain.front();
              - max == domain.back();
              - for all i &lt; n   :      min_i &lt;= max_i
              - for all i &lt; n-1 :  max_i + 1 &lt; min_{i+1}.
            
             Note that we check at validation that a variable domain is small enough so
             that we don't run into integer overflow in our algorithms. Because of that,
             you cannot just have "unbounded" variable like [0, kint64max] and should
             try to specify tighter domains.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.BoolArgumentProto">
            <summary>
            Argument of the constraints of the form OP(literals).
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.BoolArgumentProto.LiteralsFieldNumber">
            <summary>Field number for the "literals" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.IntegerArgumentProto">
            <summary>
            Argument of the constraints of the form target_var = OP(vars).
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntegerArgumentProto.TargetFieldNumber">
            <summary>Field number for the "target" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntegerArgumentProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.LinearExpressionProto">
            <summary>
            Some constraints supports linear expression instead of just using a reference
            to a variable. This is especially useful during presolve to reduce the model
            size.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearExpressionProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearExpressionProto.CoeffsFieldNumber">
            <summary>Field number for the "coeffs" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearExpressionProto.OffsetFieldNumber">
            <summary>Field number for the "offset" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearArgumentProto.TargetFieldNumber">
            <summary>Field number for the "target" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearArgumentProto.ExprsFieldNumber">
            <summary>Field number for the "exprs" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.AllDifferentConstraintProto">
            <summary>
            All variables must take different values.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.AllDifferentConstraintProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.LinearConstraintProto">
             <summary>
             The linear sum vars[i] * coeffs[i] must fall in the given domain. The domain
             has the same format as the one in IntegerVariableProto.
            
             Note that the validation code currently checks using the domain of the
             involved variables that the sum can always be computed without integer
             overflow and throws an error otherwise.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearConstraintProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearConstraintProto.CoeffsFieldNumber">
            <summary>Field number for the "coeffs" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.LinearConstraintProto.Coeffs">
            <summary>
            Same size as vars.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.LinearConstraintProto.DomainFieldNumber">
            <summary>Field number for the "domain" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.ElementConstraintProto">
            <summary>
            The constraint target = vars[index].
            This enforces that index takes one of the value in [0, vars_size()).
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ElementConstraintProto.IndexFieldNumber">
            <summary>Field number for the "index" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ElementConstraintProto.TargetFieldNumber">
            <summary>Field number for the "target" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ElementConstraintProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.IntervalConstraintProto">
            <summary>
            This "special" constraint not only enforces (start + size == end) and (size
            >= 0) but can also be referred by other constraints using this "interval"
            concept.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntervalConstraintProto.StartFieldNumber">
            <summary>Field number for the "start" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntervalConstraintProto.EndFieldNumber">
            <summary>Field number for the "end" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntervalConstraintProto.SizeFieldNumber">
            <summary>Field number for the "size" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntervalConstraintProto.StartViewFieldNumber">
            <summary>Field number for the "start_view" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.IntervalConstraintProto.StartView">
             <summary>
             EXPERIMENTAL: This will become the new way to specify an interval.
             Depending on the parameters, the presolve will convert the old way to the
             new way. Do not forget to add an associated linear constraint if you use
             this directly.
            
             If any of this field is set, then all must be set and the ones above will
             be ignored.
            
             IMPORTANT: For now, this constraint do not enforce any relations on the
             view, and a linear constraint must be added together with this to enforce
             enforcement => start_view + size_view == end_view. An enforcement =>
             size_view >=0 might also be needed.
            
             IMPORTANT: For now, we just support affine relation. We could easily
             create an intermediate variable to support full linear expression, but this
             isn't done currently.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntervalConstraintProto.EndViewFieldNumber">
            <summary>Field number for the "end_view" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.IntervalConstraintProto.SizeViewFieldNumber">
            <summary>Field number for the "size_view" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.NoOverlapConstraintProto">
            <summary>
            All the intervals (index of IntervalConstraintProto) must be disjoint. More
            formally, there must exist a sequence so that for each consecutive intervals,
            we have end_i &lt;= start_{i+1}. In particular, intervals of size zero do matter
            for this constraint. This is also known as a disjunctive constraint in
            scheduling.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.NoOverlapConstraintProto.IntervalsFieldNumber">
            <summary>Field number for the "intervals" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.NoOverlap2DConstraintProto">
            <summary>
            The boxes defined by [start_x, end_x) * [start_y, end_y) cannot overlap.
            Furthermore, one box is optional if at least one of the x or y interval is
            optional.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.NoOverlap2DConstraintProto.XIntervalsFieldNumber">
            <summary>Field number for the "x_intervals" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.NoOverlap2DConstraintProto.YIntervalsFieldNumber">
            <summary>Field number for the "y_intervals" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.NoOverlap2DConstraintProto.YIntervals">
            <summary>
            Same size as x_intervals.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.NoOverlap2DConstraintProto.BoxesWithNullAreaCanOverlapFieldNumber">
            <summary>Field number for the "boxes_with_null_area_can_overlap" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.NoOverlap2DConstraintProto.BoxesWithNullAreaCanOverlap">
            <summary>
            TODO(user): Add optional areas as repeated LinearExpressionProto.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CumulativeConstraintProto">
             <summary>
             The sum of the demands of the intervals at each interval point cannot exceed
             a capacity. Note that intervals are interpreted as [start, end) and as
             such intervals like [2,3) and [3,4) do not overlap for the point of view of
             this constraint. Moreover, intervals of size zero are ignored.
            
             TODO(user,user): Switch to linear expression for demands and capacity.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CumulativeConstraintProto.CapacityFieldNumber">
            <summary>Field number for the "capacity" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CumulativeConstraintProto.IntervalsFieldNumber">
            <summary>Field number for the "intervals" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CumulativeConstraintProto.DemandsFieldNumber">
            <summary>Field number for the "demands" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CumulativeConstraintProto.Demands">
            <summary>
            Same size as intervals.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CumulativeConstraintProto.EnergiesFieldNumber">
            <summary>Field number for the "energies" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CumulativeConstraintProto.Energies">
            <summary>
            EXPERIMENTAL: This optional field adds a redundant and more precise
            representation of the energy of a task (instead of the traditional demand *
            duration. This is only used by the linear relaxation, and it is only useful
            if both demand and durations are variable, and if the additional linear
            equation if more precise than the linear relaxation (McCormick equation) of
            the product demand * duration.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.ReservoirConstraintProto">
             <summary>
             Maintain a reservoir level within bounds. The water level starts at 0, and at
             any time, it must be within [min_level, max_level].
            
             If the variable actives[i] is true, and if the variable times[i] is assigned
             a value t, then the current level changes by demands[i] (which is constant)
             at the time t. Therefore, at any time t:
                  sum(demands[i] * actives[i] if times[i] &lt;= t) in [min_level, max_level]
            
             Note that min level must be &lt;= 0, and the max level must be >= 0. Please use
             fixed demands to simulate initial state.
            
             The array of boolean variables 'actives', if defined, indicates which actions
             are actually performed. If this array is not defined, then it is assumed that
             all actions will be performed.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.MinLevelFieldNumber">
            <summary>Field number for the "min_level" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.MaxLevelFieldNumber">
            <summary>Field number for the "max_level" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.TimesFieldNumber">
            <summary>Field number for the "times" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ReservoirConstraintProto.Times">
            <summary>
            variables.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.DemandsFieldNumber">
            <summary>Field number for the "demands" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ReservoirConstraintProto.Demands">
            <summary>
            constants, can be negative.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ReservoirConstraintProto.ActivesFieldNumber">
            <summary>Field number for the "actives" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ReservoirConstraintProto.Actives">
            <summary>
            literals.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CircuitConstraintProto">
             <summary>
             The circuit constraint is defined on a graph where the arc presence are
             controlled by literals. Each arc is given by an index in the
             tails/heads/literals lists that must have the same size.
            
             For now, we ignore node indices with no incident arc. All the other nodes
             must have exactly one incoming and one outgoing selected arc (i.e. literal at
             true). All the selected arcs that are not self-loops must form a single
             circuit. Note that multi-arcs are allowed, but only one of them will be true
             at the same time. Multi-self loop are disallowed though.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CircuitConstraintProto.TailsFieldNumber">
            <summary>Field number for the "tails" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CircuitConstraintProto.HeadsFieldNumber">
            <summary>Field number for the "heads" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CircuitConstraintProto.LiteralsFieldNumber">
            <summary>Field number for the "literals" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.RoutesConstraintProto">
             <summary>
             The "VRP" (Vehicle Routing Problem) constraint.
            
             The direct graph where arc #i (from tails[i] to head[i]) is present iff
             literals[i] is true must satisfy this set of properties:
             - #incoming arcs == 1 except for node 0.
             - #outgoing arcs == 1 except for node 0.
             - for node zero, #incoming arcs == #outgoing arcs.
             - There are no duplicate arcs.
             - Self-arcs are allowed except for node 0.
             - There is no cycle in this graph, except through node 0.
            
             Note: Currently this constraint expect all the nodes in [0, num_nodes) to
             have at least one incident arc. The model will be considered invalid if it
             is not the case. You can add self-arc fixed to one to ignore some nodes if
             needed.
            
             TODO(user): It is probably possible to generalize this constraint to a
             no-cycle in a general graph, or a no-cycle with sum incoming &lt;= 1 and sum
             outgoing &lt;= 1 (more efficient implementation). On the other hand, having this
             specific constraint allow us to add specific "cuts" to a VRP problem.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.TailsFieldNumber">
            <summary>Field number for the "tails" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.HeadsFieldNumber">
            <summary>Field number for the "heads" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.LiteralsFieldNumber">
            <summary>Field number for the "literals" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.DemandsFieldNumber">
            <summary>Field number for the "demands" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.RoutesConstraintProto.Demands">
             <summary>
             EXPERIMENTAL. The demands for each node, and the maximum capacity for each
             route. Note that this is currently only used for the LP relaxation and one
             need to add the corresponding constraint to enforce this outside of the LP.
            
             TODO(user): Ideally, we should be able to extract any dimension like these
             (i.e. capacity, route_length, etc..) automatically from the encoding. The
             classical way to encode that is to have "current_capacity" variables along
             the route and linear equations of the form:
               arc_literal => (current_capacity_tail + demand &lt;= current_capacity_head)
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.RoutesConstraintProto.CapacityFieldNumber">
            <summary>Field number for the "capacity" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.TableConstraintProto">
            <summary>
            The values of the n-tuple formed by the given variables can only be one of
            the listed n-tuples in values. The n-tuples are encoded in a flattened way:
                [tuple0_v0, tuple0_v1, ..., tuple0_v{n-1}, tuple1_v0, ...].
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.TableConstraintProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.TableConstraintProto.ValuesFieldNumber">
            <summary>Field number for the "values" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.TableConstraintProto.NegatedFieldNumber">
            <summary>Field number for the "negated" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.TableConstraintProto.Negated">
            <summary>
            If true, the meaning is "negated", that is we forbid any of the given
            tuple from a feasible assignment.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.InverseConstraintProto">
            <summary>
            The two arrays of variable each represent a function, the second is the
            inverse of the first: f_direct[i] == j &lt;=> f_inverse[j] == i.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.InverseConstraintProto.FDirectFieldNumber">
            <summary>Field number for the "f_direct" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.InverseConstraintProto.FInverseFieldNumber">
            <summary>Field number for the "f_inverse" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.AutomatonConstraintProto">
            <summary>
            This constraint forces a sequence of variables to be accepted by an
            automaton.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.StartingStateFieldNumber">
            <summary>Field number for the "starting_state" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.AutomatonConstraintProto.StartingState">
            <summary>
            A state is identified by a non-negative number. It is preferable to keep
            all the states dense in says [0, num_states). The automaton starts at
            starting_state and must finish in any of the final states.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.FinalStatesFieldNumber">
            <summary>Field number for the "final_states" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.TransitionTailFieldNumber">
            <summary>Field number for the "transition_tail" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.AutomatonConstraintProto.TransitionTail">
            <summary>
            List of transitions (all 3 vectors have the same size). Both tail and head
            are states, label is any variable value. No two outgoing transitions from
            the same state can have the same label.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.TransitionHeadFieldNumber">
            <summary>Field number for the "transition_head" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.TransitionLabelFieldNumber">
            <summary>Field number for the "transition_label" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.AutomatonConstraintProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.AutomatonConstraintProto.Vars">
            <summary>
            The sequence of variables. The automaton is ran for vars_size() "steps" and
            the value of vars[i] corresponds to the transition label at step i.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.ListOfVariablesProto">
            <summary>
            A list of variables, without any semantics.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ListOfVariablesProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.ConstraintProto">
            <summary>
            Next id: 31
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Name">
            <summary>
            For debug/logging only. Can be empty.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.EnforcementLiteralFieldNumber">
            <summary>Field number for the "enforcement_literal" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.EnforcementLiteral">
             <summary>
             The constraint will be enforced iff all literals listed here are true. If
             this is empty, then the constraint will always be enforced. An enforced
             constraint must be satisfied, and an un-enforced one will simply be
             ignored.
            
             This is also called half-reification. To have an equivalence between a
             literal and a constraint (full reification), one must add both a constraint
             (controlled by a literal l) and its negation (controlled by the negation of
             l).
            
             Important: as of September 2018, only a few constraint support enforcement:
             - bool_or, bool_and, linear: fully supported.
             - interval: only support a single enforcement literal.
             - other: no support (but can be added on a per-demand basis).
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.BoolOrFieldNumber">
            <summary>Field number for the "bool_or" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.BoolOr">
            <summary>
            The bool_or constraint forces at least one literal to be true.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.BoolAndFieldNumber">
            <summary>Field number for the "bool_and" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.BoolAnd">
             <summary>
             The bool_and constraint forces all of the literals to be true.
            
             This is a "redundant" constraint in the sense that this can easily be
             encoded with many bool_or or at_most_one. It is just more space efficient
             and handled slightly differently internally.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.AtMostOneFieldNumber">
            <summary>Field number for the "at_most_one" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.AtMostOne">
             <summary>
             The at_most_one constraint enforces that no more than one literal is
             true at the same time.
            
             Note that an at most one constraint of length n could be encoded with n
             bool_and constraint with n-1 term on the right hand side. So in a sense,
             this constraint contribute directly to the "implication-graph" or the
             2-SAT part of the model.
            
             This constraint does not support enforcement_literal. Just use a linear
             constraint if you need to enforce it. You also do not need to use it
             directly, we will extract it from the model in most situations.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.ExactlyOneFieldNumber">
            <summary>Field number for the "exactly_one" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.ExactlyOne">
             <summary>
             The exactly_one constraint force exactly one literal to true and no more.
            
             Anytime a bool_or (it could have been called at_least_one) is included
             into an at_most_one, then the bool_or is actually an exactly one
             constraint, and the extra literal in the at_most_one can be set to false.
             So in this sense, this constraint is not really needed. it is just here
             for a better description of the problem structure and to facilitate some
             algorithm.
            
             This constraint does not support enforcement_literal. Just use a linear
             constraint if you need to enforce it. You also do not need to use it
             directly, we will extract it from the model in most situations.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.BoolXorFieldNumber">
            <summary>Field number for the "bool_xor" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.BoolXor">
            <summary>
            The bool_xor constraint forces an odd number of the literals to be true.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntDivFieldNumber">
            <summary>Field number for the "int_div" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.IntDiv">
            <summary>
            The int_div constraint forces the target to equal vars[0] / vars[1].
            In particular, vars[1] can never take the value 0. Also, as for now, we
            do not support vars[1] spanning across 0.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntModFieldNumber">
            <summary>Field number for the "int_mod" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.IntMod">
            <summary>
            The int_mod constraint forces the target to equal vars[0] % vars[1].
            The domain of vars[1] must be strictly positive. The sign of the target
            is the same as the sign of vars[0].
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntMaxFieldNumber">
            <summary>Field number for the "int_max" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.IntMax">
             <summary>
             The int_max constraint forces the target to equal the maximum of all
             variables.
            
             The lin_max constraint forces the target to equal the maximum of all
             linear expressions.
            
             TODO(user): Remove int_max in favor of lin_max.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.LinMaxFieldNumber">
            <summary>Field number for the "lin_max" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntMinFieldNumber">
            <summary>Field number for the "int_min" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.IntMin">
             <summary>
             The int_min constraint forces the target to equal the minimum of all
             variables.
            
             The lin_min constraint forces the target to equal the minimum of all
             linear expressions.
            
             TODO(user): Remove int_min in favor of lin_min.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.LinMinFieldNumber">
            <summary>Field number for the "lin_min" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntProdFieldNumber">
            <summary>Field number for the "int_prod" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.IntProd">
             <summary>
             The int_prod constraint forces the target to equal the product of all
             variables. By convention, because we can just remove term equal to one,
             the empty product forces the target to be one.
            
             Note that the solver checks for potential integer overflow. So it is
             recommended to limit the domain of the variables such that the product
             fits in [INT_MIN + 1..INT_MAX - 1].
            
             TODO(user): Support more than two terms in the product.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.LinearFieldNumber">
            <summary>Field number for the "linear" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Linear">
            <summary>
            The linear constraint enforces a linear inequality among the variables,
            such as 0 &lt;= x + 2y &lt;= 10.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.AllDiffFieldNumber">
            <summary>Field number for the "all_diff" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.AllDiff">
            <summary>
            The all_diff constraint forces all variables to take different values.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.ElementFieldNumber">
            <summary>Field number for the "element" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Element">
            <summary>
            The element constraint forces the variable with the given index
            to be equal to the target.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.CircuitFieldNumber">
            <summary>Field number for the "circuit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Circuit">
            <summary>
            The circuit constraint takes a graph and forces the arcs present
            (with arc presence indicated by a literal) to form a unique cycle.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.RoutesFieldNumber">
            <summary>Field number for the "routes" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Routes">
            <summary>
            The routes constraint implements the vehicle routing problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.TableFieldNumber">
            <summary>Field number for the "table" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Table">
            <summary>
            The table constraint enforces what values a tuple of variables may
            take.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.AutomatonFieldNumber">
            <summary>Field number for the "automaton" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Automaton">
            <summary>
            The automaton constraint forces a sequence of variables to be accepted
            by an automaton.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.InverseFieldNumber">
            <summary>Field number for the "inverse" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Inverse">
            <summary>
            The inverse constraint forces two arrays to be inverses of each other:
            the values of one are the indices of the other, and vice versa.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.ReservoirFieldNumber">
            <summary>Field number for the "reservoir" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Reservoir">
            <summary>
            The reservoir constraint forces the sum of a set of active demands
            to always be between a specified minimum and maximum value during
            specific times.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.IntervalFieldNumber">
            <summary>Field number for the "interval" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Interval">
            <summary>
            The interval constraint takes a start, end, and size, and forces
            start + size == end.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.NoOverlapFieldNumber">
            <summary>Field number for the "no_overlap" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.NoOverlap">
            <summary>
            The no_overlap constraint prevents a set of intervals from
            overlapping; in scheduling, this is called a disjunctive
            constraint.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.NoOverlap2DFieldNumber">
            <summary>Field number for the "no_overlap_2d" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.NoOverlap2D">
            <summary>
            The no_overlap_2d constraint prevents a set of boxes from overlapping.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.CumulativeFieldNumber">
            <summary>Field number for the "cumulative" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.Cumulative">
            <summary>
            The cumulative constraint ensures that for any integer point, the sum
            of the demands of the intervals containing that point does not exceed
            the capacity.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.ConstraintProto.DummyConstraintFieldNumber">
            <summary>Field number for the "dummy_constraint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.ConstraintProto.DummyConstraint">
            <summary>
            This constraint is not meant to be used and will be rejected by the
            solver. It is meant to mark variable when testing the presolve code.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.ConstraintProto.ConstraintOneofCase">
            <summary>Enum of possible cases for the "constraint" oneof.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpObjectiveProto">
             <summary>
             Optimization objective.
            
             This is in a message because decision problems don't have any objective.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpObjectiveProto.Vars">
            <summary>
            The linear terms of the objective to minimize.
            For a maximization problem, one can negate all coefficients in the
            objective and set a scaling_factor to -1.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.CoeffsFieldNumber">
            <summary>Field number for the "coeffs" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.OffsetFieldNumber">
            <summary>Field number for the "offset" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpObjectiveProto.Offset">
             <summary>
             The displayed objective is always:
               scaling_factor * (sum(coefficients[i] * objective_vars[i]) + offset).
             This is needed to have a consistent objective after presolve or when
             scaling a double problem to express it with integers.
            
             Note that if scaling_factor is zero, then it is assumed to be 1, so that by
             default these fields have no effect.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.ScalingFactorFieldNumber">
            <summary>Field number for the "scaling_factor" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpObjectiveProto.DomainFieldNumber">
            <summary>Field number for the "domain" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpObjectiveProto.Domain">
            <summary>
            If non-empty, only look for an objective value in the given domain.
            Note that this does not depend on the offset or scaling factor, it is a
            domain on the sum of the objective terms only.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.DecisionStrategyProto">
            <summary>
            Define the strategy to follow when the solver needs to take a new decision.
            Note that this strategy is only defined on a subset of variables.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.VariablesFieldNumber">
            <summary>Field number for the "variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.DecisionStrategyProto.Variables">
            <summary>
            The variables to be considered for the next decision. The order matter and
            is always used as a tie-breaker after the variable selection strategy
            criteria defined below.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.VariableSelectionStrategyFieldNumber">
            <summary>Field number for the "variable_selection_strategy" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.DomainReductionStrategyFieldNumber">
            <summary>Field number for the "domain_reduction_strategy" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.TransformationsFieldNumber">
            <summary>Field number for the "transformations" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.DecisionStrategyProto.Types">
            <summary>Container for nested types declared in the DecisionStrategyProto message type.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.DecisionStrategyProto.Types.VariableSelectionStrategy">
             <summary>
             The order in which the variables above should be considered. Note that only
             variables that are not already fixed are considered.
            
             TODO(user): extend as needed.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.DecisionStrategyProto.Types.DomainReductionStrategy">
             <summary>
             Once a variable has been chosen, this enum describe what decision is taken
             on its domain.
            
             TODO(user): extend as needed.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.DecisionStrategyProto.Types.AffineTransformation">
            <summary>
            Advanced usage. Some of the variable listed above may have been transformed
            by the presolve so this is needed to properly follow the given selection
            strategy. Instead of using a value X for variables[index], we will use
            positive_coeff * X + offset instead.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.Types.AffineTransformation.IndexFieldNumber">
            <summary>Field number for the "index" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.Types.AffineTransformation.OffsetFieldNumber">
            <summary>Field number for the "offset" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.DecisionStrategyProto.Types.AffineTransformation.PositiveCoeffFieldNumber">
            <summary>Field number for the "positive_coeff" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.PartialVariableAssignment">
            <summary>
            This message encodes a partial (or full) assignment of the variables of a
            CpModelProto. The variable indices should be unique and valid variable
            indices.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.PartialVariableAssignment.VarsFieldNumber">
            <summary>Field number for the "vars" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.PartialVariableAssignment.ValuesFieldNumber">
            <summary>Field number for the "values" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SparsePermutationProto">
            <summary>
            A permutation of integers encoded as a list of cycles, hence the "sparse"
            format. The image of an element cycle[i] is cycle[(i + 1) % cycle_length].
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SparsePermutationProto.SupportFieldNumber">
            <summary>Field number for the "support" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SparsePermutationProto.Support">
            <summary>
            Each cycle is listed one after the other in the support field.
            The size of each cycle is given (in order) in the cycle_sizes field.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SparsePermutationProto.CycleSizesFieldNumber">
            <summary>Field number for the "cycle_sizes" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.DenseMatrixProto">
            <summary>
            A dense matrix of numbers encoded in a flat way, row by row.
            That is matrix[i][j] = entries[i * num_cols + j];
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.DenseMatrixProto.NumRowsFieldNumber">
            <summary>Field number for the "num_rows" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.DenseMatrixProto.NumColsFieldNumber">
            <summary>Field number for the "num_cols" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.DenseMatrixProto.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SymmetryProto">
             <summary>
             EXPERIMENTAL. For now, this is meant to be used by the solver and not filled
             by clients.
            
             Hold symmetry information about the set of feasible solutions. If we permute
             the variable values of any feasible solution using one of the permutation
             described here, we should always get another feasible solution.
            
             We usually also enforce that the objective of the new solution is the same.
            
             The group of permutations encoded here is usually computed from the encoding
             of the model, so it is not meant to be a complete representation of the
             feasible solution symmetries, just a valid subgroup.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SymmetryProto.PermutationsFieldNumber">
            <summary>Field number for the "permutations" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SymmetryProto.Permutations">
            <summary>
            A list of variable indices permutations that leave the feasible space of
            solution invariant. Usually, we only encode a set of generators of the
            group.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SymmetryProto.OrbitopesFieldNumber">
            <summary>Field number for the "orbitopes" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SymmetryProto.Orbitopes">
             <summary>
             An orbitope is a special symmetry structure of the solution space. If the
             variable indices are arranged in a matrix (with no duplicates), then any
             permutation of the columns will be a valid permutation of the feasible
             space.
            
             This arise quite often. The typical example is a graph coloring problem
             where for each node i, you have j booleans to indicate its color. If the
             variables color_of_i_is_j are arranged in a matrix[i][j], then any columns
             permutations leave the problem invariant.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpModelProto">
            <summary>
            A constraint programming problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Name">
            <summary>
            For debug/logging only. Can be empty.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.VariablesFieldNumber">
            <summary>Field number for the "variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Variables">
            <summary>
            The associated Protos should be referred by their index in these fields.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.ConstraintsFieldNumber">
            <summary>Field number for the "constraints" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.ObjectiveFieldNumber">
            <summary>Field number for the "objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Objective">
            <summary>
            The objective to minimize. Can be empty for pure decision problems.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.SearchStrategyFieldNumber">
            <summary>Field number for the "search_strategy" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.SearchStrategy">
             <summary>
             Defines the strategy that the solver should follow when the
             search_branching parameter is set to FIXED_SEARCH. Note that this strategy
             is also used as a heuristic when we are not in fixed search.
            
             Advanced Usage: if not all variables appears and the parameter
             "instantiate_all_variables" is set to false, then the solver will not try
             to instantiate the variables that do not appear. Thus, at the end of the
             search, not all variables may be fixed and this is why we have the
             solution_lower_bounds and solution_upper_bounds fields in the
             CpSolverResponse.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.SolutionHintFieldNumber">
            <summary>Field number for the "solution_hint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.SolutionHint">
             <summary>
             Solution hint.
            
             If a feasible or almost-feasible solution to the problem is already known,
             it may be helpful to pass it to the solver so that it can be used. The
             solver will try to use this information to create its initial feasible
             solution.
            
             Note that it may not always be faster to give a hint like this to the
             solver. There is also no guarantee that the solver will use this hint or
             try to return a solution "close" to this assignment in case of multiple
             optimal solutions.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.AssumptionsFieldNumber">
            <summary>Field number for the "assumptions" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Assumptions">
             <summary>
             A list of literals. The model will be solved assuming all these literals
             are true. Compared to just fixing the domain of these literals, using this
             mechanism is slower but allows in case the model is INFEASIBLE to get a
             potentially small subset of them that can be used to explain the
             infeasibility.
            
             Think (IIS), except when you are only concerned by the provided
             assumptions. This is powerful as it allows to group a set of logicially
             related constraint under only one enforcement literal which can potentially
             give you a good and interpretable explanation for infeasiblity.
            
             Such infeasibility explanation will be available in the
             sufficient_assumptions_for_infeasibility response field.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpModelProto.SymmetryFieldNumber">
            <summary>Field number for the "symmetry" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpModelProto.Symmetry">
             <summary>
             For now, this is not meant to be filled by a client writing a model, but
             by our preprocessing step.
            
             Information about the symmetries of the feasible solution space.
             These usually leaves the objective invariant.
             </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpSolverResponse">
             <summary>
             The response returned by a solver trying to solve a CpModelProto.
            
             TODO(user): support returning multiple solutions. Look at the Stubby
             streaming API as we probably wants to get them as they are found.
             Next id: 27
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.StatusFieldNumber">
            <summary>Field number for the "status" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.Status">
            <summary>
            The status of the solve.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SolutionFieldNumber">
            <summary>Field number for the "solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.Solution">
            <summary>
            A feasible solution to the given problem. Depending on the returned status
            it may be optimal or just feasible. This is in one-to-one correspondence
            with a CpModelProto::variables repeated field and list the values of all
            the variables.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.ObjectiveValueFieldNumber">
            <summary>Field number for the "objective_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.ObjectiveValue">
            <summary>
            Only make sense for an optimization problem. The objective value of the
            returned solution if it is non-empty. If there is no solution, then for a
            minimization problem, this will be an upper-bound of the objective of any
            feasible solution, and a lower-bound for a maximization problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.BestObjectiveBoundFieldNumber">
            <summary>Field number for the "best_objective_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.BestObjectiveBound">
            <summary>
            Only make sense for an optimization problem. A proven lower-bound on the
            objective for a minimization problem, or a proven upper-bound for a
            maximization problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SolutionLowerBoundsFieldNumber">
            <summary>Field number for the "solution_lower_bounds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.SolutionLowerBounds">
             <summary>
             Advanced usage.
            
             If the problem has some variables that are not fixed at the end of the
             search (because of a particular search strategy in the CpModelProto) then
             this will be used instead of filling the solution above. The two fields
             will then contains the lower and upper bounds of each variable as they were
             when the best "solution" was found.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SolutionUpperBoundsFieldNumber">
            <summary>Field number for the "solution_upper_bounds" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.TightenedVariablesFieldNumber">
            <summary>Field number for the "tightened_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.TightenedVariables">
             <summary>
             Advanced usage.
            
             If the option fill_tightened_domains_in_response is set, then this field
             will be a copy of the CpModelProto.variables where each domain has been
             reduced using the information the solver was able to derive. Note that this
             is only filled with the info derived during a normal search and we do not
             have any dedicated algorithm to improve it.
            
             If the problem is a feasibility problem, then these bounds will be valid
             for any feasible solution. If the problem is an optimization problem, then
             these bounds will only be valid for any OPTIMAL solutions, it can exclude
             sub-optimal feasible ones.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SufficientAssumptionsForInfeasibilityFieldNumber">
            <summary>Field number for the "sufficient_assumptions_for_infeasibility" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.SufficientAssumptionsForInfeasibility">
             <summary>
             A subset of the model "assumptions" field. This will only be filled if the
             status is INFEASIBLE. This subset of assumption will be enough to still get
             an infeasible problem.
            
             This is related to what is called the irreducible inconsistent subsystem or
             IIS. Except one is only concerned by the provided assumptions. There is
             also no guarantee that we return an irreducible (aka minimal subset).
             However, this is based on SAT explanation and there is a good chance it is
             not too large.
            
             If you really want a minimal subset, a possible way to get one is by
             changing your model to minimize the number of assumptions at false, but
             this is likely an harder problem to solve.
            
             Important: Currently, this is minimized only in single-thread and if the
             problem is not an optimization problem, otherwise, it will always include
             all the assumptions.
            
             TODO(user): Allows for returning multiple core at once.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.AllSolutionsWereFoundFieldNumber">
            <summary>Field number for the "all_solutions_were_found" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.AllSolutionsWereFound">
             <summary>
             This will be true iff the solver was asked to find all solutions to a
             satisfiability problem (or all optimal solutions to an optimization
             problem), and it was successful in doing so.
            
             TODO(user): Remove as we also use the OPTIMAL vs FEASIBLE status for that.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumBooleansFieldNumber">
            <summary>Field number for the "num_booleans" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.NumBooleans">
            <summary>
            Some statistics about the solve.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumConflictsFieldNumber">
            <summary>Field number for the "num_conflicts" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumBranchesFieldNumber">
            <summary>Field number for the "num_branches" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumBinaryPropagationsFieldNumber">
            <summary>Field number for the "num_binary_propagations" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumIntegerPropagationsFieldNumber">
            <summary>Field number for the "num_integer_propagations" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumRestartsFieldNumber">
            <summary>Field number for the "num_restarts" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.NumLpIterationsFieldNumber">
            <summary>Field number for the "num_lp_iterations" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.WallTimeFieldNumber">
            <summary>Field number for the "wall_time" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.UserTimeFieldNumber">
            <summary>Field number for the "user_time" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.DeterministicTimeFieldNumber">
            <summary>Field number for the "deterministic_time" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.PrimalIntegralFieldNumber">
            <summary>Field number for the "primal_integral" field.</summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SolutionInfoFieldNumber">
            <summary>Field number for the "solution_info" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.SolutionInfo">
            <summary>
            Additional information about how the solution was found.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.CpSolverResponse.SolveLogFieldNumber">
            <summary>Field number for the "solve_log" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.CpSolverResponse.SolveLog">
            <summary>
            The solve log will be filled if the parameter log_to_response is set to
            true.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParametersReflection">
            <summary>Holder for reflection information generated from ortools/sat/sat_parameters.proto</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParametersReflection.Descriptor">
            <summary>File descriptor for ortools/sat/sat_parameters.proto</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters">
             <summary>
             Contains the definitions for all the sat algorithm parameters and their
             default values.
            
             NEXT TAG: 194
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NameFieldNumber">
            <summary>Field number for the "name" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.Name">
            <summary>
            In some context, like in a portfolio of search, it makes sense to name a
            given parameters set for logging purpose.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasName">
            <summary>Gets whether the "name" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearName">
            <summary>Clears the value of the "name" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PreferredVariableOrderFieldNumber">
            <summary>Field number for the "preferred_variable_order" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPreferredVariableOrder">
            <summary>Gets whether the "preferred_variable_order" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPreferredVariableOrder">
            <summary>Clears the value of the "preferred_variable_order" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InitialPolarityFieldNumber">
            <summary>Field number for the "initial_polarity" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInitialPolarity">
            <summary>Gets whether the "initial_polarity" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInitialPolarity">
            <summary>Clears the value of the "initial_polarity" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UsePhaseSavingFieldNumber">
            <summary>Field number for the "use_phase_saving" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UsePhaseSaving">
             <summary>
             If this is true, then the polarity of a variable will be the last value it
             was assigned to, or its default polarity if it was never assigned since the
             call to ResetDecisionHeuristic().
            
             Actually, we use a newer version where we follow the last value in the
             longest non-conflicting partial assignment in the current phase.
            
             This is called 'literal phase saving'. For details see 'A Lightweight
             Component Caching Scheme for Satisfiability Solvers' K. Pipatsrisawat and
             A.Darwiche, In 10th International Conference on Theory and Applications of
             Satisfiability Testing, 2007.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUsePhaseSaving">
            <summary>Gets whether the "use_phase_saving" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUsePhaseSaving">
            <summary>Clears the value of the "use_phase_saving" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PolarityRephaseIncrementFieldNumber">
            <summary>Field number for the "polarity_rephase_increment" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PolarityRephaseIncrement">
            <summary>
            If non-zero, then we change the polarity heuristic after that many number
            of conflicts in an arithmetically increasing fashion. So x the first time,
            2 * x the second time, etc...
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPolarityRephaseIncrement">
            <summary>Gets whether the "polarity_rephase_increment" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPolarityRephaseIncrement">
            <summary>Clears the value of the "polarity_rephase_increment" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RandomPolarityRatioFieldNumber">
            <summary>Field number for the "random_polarity_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RandomPolarityRatio">
            <summary>
            The proportion of polarity chosen at random. Note that this take
            precedence over the phase saving heuristic. This is different from
            initial_polarity:POLARITY_RANDOM because it will select a new random
            polarity each time the variable is branched upon instead of selecting one
            initially and then always taking this choice.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRandomPolarityRatio">
            <summary>Gets whether the "random_polarity_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRandomPolarityRatio">
            <summary>Clears the value of the "random_polarity_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RandomBranchesRatioFieldNumber">
            <summary>Field number for the "random_branches_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RandomBranchesRatio">
            <summary>
            A number between 0 and 1 that indicates the proportion of branching
            variables that are selected randomly instead of choosing the first variable
            from the given variable_ordering strategy.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRandomBranchesRatio">
            <summary>Gets whether the "random_branches_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRandomBranchesRatio">
            <summary>Clears the value of the "random_branches_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseErwaHeuristicFieldNumber">
            <summary>Field number for the "use_erwa_heuristic" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseErwaHeuristic">
            <summary>
            Whether we use the ERWA (Exponential Recency Weighted Average) heuristic as
            described in "Learning Rate Based Branching Heuristic for SAT solvers",
            J.H.Liang, V. Ganesh, P. Poupart, K.Czarnecki, SAT 2016.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseErwaHeuristic">
            <summary>Gets whether the "use_erwa_heuristic" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseErwaHeuristic">
            <summary>Clears the value of the "use_erwa_heuristic" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InitialVariablesActivityFieldNumber">
            <summary>Field number for the "initial_variables_activity" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InitialVariablesActivity">
            <summary>
            The initial value of the variables activity. A non-zero value only make
            sense when use_erwa_heuristic is true. Experiments with a value of 1e-2
            together with the ERWA heuristic showed slighthly better result than simply
            using zero. The idea is that when the "learning rate" of a variable becomes
            lower than this value, then we prefer to branch on never explored before
            variables. This is not in the ERWA paper.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInitialVariablesActivity">
            <summary>Gets whether the "initial_variables_activity" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInitialVariablesActivity">
            <summary>Clears the value of the "initial_variables_activity" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AlsoBumpVariablesInConflictReasonsFieldNumber">
            <summary>Field number for the "also_bump_variables_in_conflict_reasons" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AlsoBumpVariablesInConflictReasons">
            <summary>
            When this is true, then the variables that appear in any of the reason of
            the variables in a conflict have their activity bumped. This is addition to
            the variables in the conflict, and the one that were used during conflict
            resolution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAlsoBumpVariablesInConflictReasons">
            <summary>Gets whether the "also_bump_variables_in_conflict_reasons" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAlsoBumpVariablesInConflictReasons">
            <summary>Clears the value of the "also_bump_variables_in_conflict_reasons" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MinimizationAlgorithmFieldNumber">
            <summary>Field number for the "minimization_algorithm" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMinimizationAlgorithm">
            <summary>Gets whether the "minimization_algorithm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMinimizationAlgorithm">
            <summary>Clears the value of the "minimization_algorithm" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BinaryMinimizationAlgorithmFieldNumber">
            <summary>Field number for the "binary_minimization_algorithm" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBinaryMinimizationAlgorithm">
            <summary>Gets whether the "binary_minimization_algorithm" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBinaryMinimizationAlgorithm">
            <summary>Clears the value of the "binary_minimization_algorithm" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SubsumptionDuringConflictAnalysisFieldNumber">
            <summary>Field number for the "subsumption_during_conflict_analysis" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SubsumptionDuringConflictAnalysis">
            <summary>
            At a really low cost, during the 1-UIP conflict computation, it is easy to
            detect if some of the involved reasons are subsumed by the current
            conflict. When this is true, such clauses are detached and later removed
            from the problem.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSubsumptionDuringConflictAnalysis">
            <summary>Gets whether the "subsumption_during_conflict_analysis" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSubsumptionDuringConflictAnalysis">
            <summary>Clears the value of the "subsumption_during_conflict_analysis" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupPeriodFieldNumber">
            <summary>Field number for the "clause_cleanup_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseCleanupPeriod">
            <summary>
            Trigger a cleanup when this number of "deletable" clauses is learned.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupPeriod">
            <summary>Gets whether the "clause_cleanup_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupPeriod">
            <summary>Clears the value of the "clause_cleanup_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupTargetFieldNumber">
            <summary>Field number for the "clause_cleanup_target" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseCleanupTarget">
            <summary>
            During a cleanup, we will always keep that number of "deletable" clauses.
            Note that this doesn't include the "protected" clauses.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupTarget">
            <summary>Gets whether the "clause_cleanup_target" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupTarget">
            <summary>Clears the value of the "clause_cleanup_target" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupRatioFieldNumber">
            <summary>Field number for the "clause_cleanup_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseCleanupRatio">
            <summary>
            During a cleanup, if clause_cleanup_target is 0, we will delete the
            clause_cleanup_ratio of "deletable" clauses instead of aiming for a fixed
            target of clauses to keep.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupRatio">
            <summary>Gets whether the "clause_cleanup_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupRatio">
            <summary>Clears the value of the "clause_cleanup_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupProtectionFieldNumber">
            <summary>Field number for the "clause_cleanup_protection" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupProtection">
            <summary>Gets whether the "clause_cleanup_protection" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupProtection">
            <summary>Clears the value of the "clause_cleanup_protection" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupLbdBoundFieldNumber">
            <summary>Field number for the "clause_cleanup_lbd_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseCleanupLbdBound">
            <summary>
            All the clauses with a LBD (literal blocks distance) lower or equal to this
            parameters will always be kept.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupLbdBound">
            <summary>Gets whether the "clause_cleanup_lbd_bound" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupLbdBound">
            <summary>Clears the value of the "clause_cleanup_lbd_bound" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseCleanupOrderingFieldNumber">
            <summary>Field number for the "clause_cleanup_ordering" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseCleanupOrdering">
            <summary>Gets whether the "clause_cleanup_ordering" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseCleanupOrdering">
            <summary>Clears the value of the "clause_cleanup_ordering" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PbCleanupIncrementFieldNumber">
            <summary>Field number for the "pb_cleanup_increment" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PbCleanupIncrement">
            <summary>
            Same as for the clauses, but for the learned pseudo-Boolean constraints.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPbCleanupIncrement">
            <summary>Gets whether the "pb_cleanup_increment" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPbCleanupIncrement">
            <summary>Clears the value of the "pb_cleanup_increment" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PbCleanupRatioFieldNumber">
            <summary>Field number for the "pb_cleanup_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPbCleanupRatio">
            <summary>Gets whether the "pb_cleanup_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPbCleanupRatio">
            <summary>Clears the value of the "pb_cleanup_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MinimizeWithPropagationRestartPeriodFieldNumber">
            <summary>Field number for the "minimize_with_propagation_restart_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MinimizeWithPropagationRestartPeriod">
             <summary>
             Parameters for an heuristic similar to the one descibed in "An effective
             learnt clause minimization approach for CDCL Sat Solvers",
             https://www.ijcai.org/proceedings/2017/0098.pdf
            
             For now, we have a somewhat simpler implementation where every x restart we
             spend y decisions on clause minimization. The minimization technique is the
             same as the one used to minimize core in max-sat. We also minimize problem
             clauses and not just the learned clause that we keep forever like in the
             paper.
            
             Changing these parameters or the kind of clause we minimize seems to have
             a big impact on the overall perf on our benchmarks. So this technique seems
             definitely useful, but it is hard to tune properly.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMinimizeWithPropagationRestartPeriod">
            <summary>Gets whether the "minimize_with_propagation_restart_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMinimizeWithPropagationRestartPeriod">
            <summary>Clears the value of the "minimize_with_propagation_restart_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MinimizeWithPropagationNumDecisionsFieldNumber">
            <summary>Field number for the "minimize_with_propagation_num_decisions" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMinimizeWithPropagationNumDecisions">
            <summary>Gets whether the "minimize_with_propagation_num_decisions" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMinimizeWithPropagationNumDecisions">
            <summary>Clears the value of the "minimize_with_propagation_num_decisions" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.VariableActivityDecayFieldNumber">
            <summary>Field number for the "variable_activity_decay" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.VariableActivityDecay">
             <summary>
             Each time a conflict is found, the activities of some variables are
             increased by one. Then, the activity of all variables are multiplied by
             variable_activity_decay.
            
             To implement this efficiently, the activity of all the variables is not
             decayed at each conflict. Instead, the activity increment is multiplied by
             1 / decay. When an activity reach max_variable_activity_value, all the
             activity are multiplied by 1 / max_variable_activity_value.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasVariableActivityDecay">
            <summary>Gets whether the "variable_activity_decay" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearVariableActivityDecay">
            <summary>Clears the value of the "variable_activity_decay" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxVariableActivityValueFieldNumber">
            <summary>Field number for the "max_variable_activity_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxVariableActivityValue">
            <summary>Gets whether the "max_variable_activity_value" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxVariableActivityValue">
            <summary>Clears the value of the "max_variable_activity_value" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.GlucoseMaxDecayFieldNumber">
            <summary>Field number for the "glucose_max_decay" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.GlucoseMaxDecay">
             <summary>
             The activity starts at 0.8 and increment by 0.01 every 5000 conflicts until
             0.95. This "hack" seems to work well and comes from:
            
             Glucose 2.3 in the SAT 2013 Competition - SAT Competition 2013
             http://edacc4.informatik.uni-ulm.de/SC13/solver-description-download/136
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasGlucoseMaxDecay">
            <summary>Gets whether the "glucose_max_decay" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearGlucoseMaxDecay">
            <summary>Clears the value of the "glucose_max_decay" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.GlucoseDecayIncrementFieldNumber">
            <summary>Field number for the "glucose_decay_increment" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasGlucoseDecayIncrement">
            <summary>Gets whether the "glucose_decay_increment" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearGlucoseDecayIncrement">
            <summary>Clears the value of the "glucose_decay_increment" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.GlucoseDecayIncrementPeriodFieldNumber">
            <summary>Field number for the "glucose_decay_increment_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasGlucoseDecayIncrementPeriod">
            <summary>Gets whether the "glucose_decay_increment_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearGlucoseDecayIncrementPeriod">
            <summary>Clears the value of the "glucose_decay_increment_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ClauseActivityDecayFieldNumber">
            <summary>Field number for the "clause_activity_decay" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ClauseActivityDecay">
            <summary>
            Clause activity parameters (same effect as the one on the variables).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasClauseActivityDecay">
            <summary>Gets whether the "clause_activity_decay" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearClauseActivityDecay">
            <summary>Clears the value of the "clause_activity_decay" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxClauseActivityValueFieldNumber">
            <summary>Field number for the "max_clause_activity_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxClauseActivityValue">
            <summary>Gets whether the "max_clause_activity_value" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxClauseActivityValue">
            <summary>Clears the value of the "max_clause_activity_value" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartAlgorithmsFieldNumber">
            <summary>Field number for the "restart_algorithms" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RestartAlgorithms">
             <summary>
             The restart strategies will change each time the strategy_counter is
             increased. The current strategy will simply be the one at index
             strategy_counter modulo the number of strategy. Note that if this list
             includes a NO_RESTART, nothing will change when it is reached because the
             strategy_counter will only increment after a restart.
            
             The idea of switching of search strategy tailored for SAT/UNSAT comes from
             Chanseok Oh with his COMiniSatPS solver, see http://cs.nyu.edu/~chanseok/.
             But more generally, it seems REALLY beneficial to try different strategy.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DefaultRestartAlgorithmsFieldNumber">
            <summary>Field number for the "default_restart_algorithms" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDefaultRestartAlgorithms">
            <summary>Gets whether the "default_restart_algorithms" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDefaultRestartAlgorithms">
            <summary>Clears the value of the "default_restart_algorithms" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartPeriodFieldNumber">
            <summary>Field number for the "restart_period" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RestartPeriod">
            <summary>
            Restart period for the FIXED_RESTART strategy. This is also the multiplier
            used by the LUBY_RESTART strategy.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRestartPeriod">
            <summary>Gets whether the "restart_period" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRestartPeriod">
            <summary>Clears the value of the "restart_period" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartRunningWindowSizeFieldNumber">
            <summary>Field number for the "restart_running_window_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RestartRunningWindowSize">
            <summary>
            Size of the window for the moving average restarts.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRestartRunningWindowSize">
            <summary>Gets whether the "restart_running_window_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRestartRunningWindowSize">
            <summary>Clears the value of the "restart_running_window_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartDlAverageRatioFieldNumber">
            <summary>Field number for the "restart_dl_average_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RestartDlAverageRatio">
            <summary>
            In the moving average restart algorithms, a restart is triggered if the
            window average times this ratio is greater that the global average.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRestartDlAverageRatio">
            <summary>Gets whether the "restart_dl_average_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRestartDlAverageRatio">
            <summary>Clears the value of the "restart_dl_average_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RestartLbdAverageRatioFieldNumber">
            <summary>Field number for the "restart_lbd_average_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRestartLbdAverageRatio">
            <summary>Gets whether the "restart_lbd_average_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRestartLbdAverageRatio">
            <summary>Clears the value of the "restart_lbd_average_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseBlockingRestartFieldNumber">
            <summary>Field number for the "use_blocking_restart" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseBlockingRestart">
            <summary>
            Block a moving restart algorithm if the trail size of the current conflict
            is greater than the multiplier times the moving average of the trail size
            at the previous conflicts.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseBlockingRestart">
            <summary>Gets whether the "use_blocking_restart" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseBlockingRestart">
            <summary>Clears the value of the "use_blocking_restart" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BlockingRestartWindowSizeFieldNumber">
            <summary>Field number for the "blocking_restart_window_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBlockingRestartWindowSize">
            <summary>Gets whether the "blocking_restart_window_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBlockingRestartWindowSize">
            <summary>Clears the value of the "blocking_restart_window_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BlockingRestartMultiplierFieldNumber">
            <summary>Field number for the "blocking_restart_multiplier" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBlockingRestartMultiplier">
            <summary>Gets whether the "blocking_restart_multiplier" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBlockingRestartMultiplier">
            <summary>Clears the value of the "blocking_restart_multiplier" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NumConflictsBeforeStrategyChangesFieldNumber">
            <summary>Field number for the "num_conflicts_before_strategy_changes" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.NumConflictsBeforeStrategyChanges">
            <summary>
            After each restart, if the number of conflict since the last strategy
            change is greater that this, then we increment a "strategy_counter" that
            can be use to change the search strategy used by the following restarts.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNumConflictsBeforeStrategyChanges">
            <summary>Gets whether the "num_conflicts_before_strategy_changes" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNumConflictsBeforeStrategyChanges">
            <summary>Clears the value of the "num_conflicts_before_strategy_changes" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.StrategyChangeIncreaseRatioFieldNumber">
            <summary>Field number for the "strategy_change_increase_ratio" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.StrategyChangeIncreaseRatio">
            <summary>
            The parameter num_conflicts_before_strategy_changes is increased by that
            much after each strategy change.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasStrategyChangeIncreaseRatio">
            <summary>Gets whether the "strategy_change_increase_ratio" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearStrategyChangeIncreaseRatio">
            <summary>Clears the value of the "strategy_change_increase_ratio" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxTimeInSecondsFieldNumber">
            <summary>Field number for the "max_time_in_seconds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxTimeInSeconds">
            <summary>
            Maximum time allowed in seconds to solve a problem.
            The counter will starts at the beginning of the Solve() call.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxTimeInSeconds">
            <summary>Gets whether the "max_time_in_seconds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxTimeInSeconds">
            <summary>Clears the value of the "max_time_in_seconds" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxDeterministicTimeFieldNumber">
            <summary>Field number for the "max_deterministic_time" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxDeterministicTime">
            <summary>
            Maximum time allowed in deterministic time to solve a problem.
            The deterministic time should be correlated with the real time used by the
            solver, the time unit being as close as possible to a second.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxDeterministicTime">
            <summary>Gets whether the "max_deterministic_time" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxDeterministicTime">
            <summary>Clears the value of the "max_deterministic_time" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxNumberOfConflictsFieldNumber">
            <summary>Field number for the "max_number_of_conflicts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxNumberOfConflicts">
             <summary>
             Maximum number of conflicts allowed to solve a problem.
            
             TODO(user,user): Maybe change the way the conflict limit is enforced?
             currently it is enforced on each independent internal SAT solve, rather
             than on the overall number of conflicts across all solves. So in the
             context of an optimization problem, this is not really usable directly by a
             client.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxNumberOfConflicts">
            <summary>Gets whether the "max_number_of_conflicts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxNumberOfConflicts">
            <summary>Clears the value of the "max_number_of_conflicts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxMemoryInMbFieldNumber">
            <summary>Field number for the "max_memory_in_mb" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxMemoryInMb">
            <summary>
            Maximum memory allowed for the whole thread containing the solver. The
            solver will abort as soon as it detects that this limit is crossed. As a
            result, this limit is approximative, but usually the solver will not go too
            much over.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxMemoryInMb">
            <summary>Gets whether the "max_memory_in_mb" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxMemoryInMb">
            <summary>Clears the value of the "max_memory_in_mb" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AbsoluteGapLimitFieldNumber">
            <summary>Field number for the "absolute_gap_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AbsoluteGapLimit">
             <summary>
             Stop the search when the gap between the best feasible objective (O) and
             our best objective bound (B) is smaller than a limit.
             The exact definition is:
             - Absolute: abs(O - B)
             - Relative: abs(O - B) / max(1, abs(O)).
            
             Important: The relative gap depends on the objective offset! If you
             artificially shift the objective, you will get widely different value of
             the relative gap.
            
             Note that if the gap is reached, the search status will be OPTIMAL. But
             one can check the best objective bound to see the actual gap.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAbsoluteGapLimit">
            <summary>Gets whether the "absolute_gap_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAbsoluteGapLimit">
            <summary>Clears the value of the "absolute_gap_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RelativeGapLimitFieldNumber">
            <summary>Field number for the "relative_gap_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRelativeGapLimit">
            <summary>Gets whether the "relative_gap_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRelativeGapLimit">
            <summary>Clears the value of the "relative_gap_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.TreatBinaryClausesSeparatelyFieldNumber">
            <summary>Field number for the "treat_binary_clauses_separately" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.TreatBinaryClausesSeparately">
            <summary>
            If true, the binary clauses are treated separately from the others. This
            should be faster and uses less memory. However it changes the propagation
            order.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasTreatBinaryClausesSeparately">
            <summary>Gets whether the "treat_binary_clauses_separately" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearTreatBinaryClausesSeparately">
            <summary>Clears the value of the "treat_binary_clauses_separately" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RandomSeedFieldNumber">
            <summary>Field number for the "random_seed" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RandomSeed">
             <summary>
             At the beginning of each solve, the random number generator used in some
             part of the solver is reinitialized to this seed. If you change the random
             seed, the solver may make different choices during the solving process.
            
             For some problems, the running time may vary a lot depending on small
             change in the solving algorithm. Running the solver with different seeds
             enables to have more robust benchmarks when evaluating new features.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRandomSeed">
            <summary>Gets whether the "random_seed" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRandomSeed">
            <summary>Clears the value of the "random_seed" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PermuteVariableRandomlyFieldNumber">
            <summary>Field number for the "permute_variable_randomly" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PermuteVariableRandomly">
            <summary>
            This is mainly here to test the solver variability. Note that in tests, if
            not explicitly set to false, all 3 options will be set to true so that
            clients do not rely on the solver returning a specific solution if they are
            many equivalent optimal solutions.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPermuteVariableRandomly">
            <summary>Gets whether the "permute_variable_randomly" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPermuteVariableRandomly">
            <summary>Clears the value of the "permute_variable_randomly" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PermutePresolveConstraintOrderFieldNumber">
            <summary>Field number for the "permute_presolve_constraint_order" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPermutePresolveConstraintOrder">
            <summary>Gets whether the "permute_presolve_constraint_order" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPermutePresolveConstraintOrder">
            <summary>Clears the value of the "permute_presolve_constraint_order" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseAbslRandomFieldNumber">
            <summary>Field number for the "use_absl_random" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseAbslRandom">
            <summary>Gets whether the "use_absl_random" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseAbslRandom">
            <summary>Clears the value of the "use_absl_random" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogSearchProgressFieldNumber">
            <summary>Field number for the "log_search_progress" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogSearchProgress">
            <summary>
            Whether the solver should log the search progress. By default, it logs to
            LOG(INFO). This can be overwritten by the log_destination parameter.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogSearchProgress">
            <summary>Gets whether the "log_search_progress" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogSearchProgress">
            <summary>Clears the value of the "log_search_progress" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogSubsolverStatisticsFieldNumber">
            <summary>Field number for the "log_subsolver_statistics" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogSubsolverStatistics">
            <summary>
            Whether the solver should display per sub-solver search statistics.
            This is only useful is log_search_progress is set to true, and if the
            number of search workers is > 1.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogSubsolverStatistics">
            <summary>Gets whether the "log_subsolver_statistics" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogSubsolverStatistics">
            <summary>Clears the value of the "log_subsolver_statistics" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogPrefixFieldNumber">
            <summary>Field number for the "log_prefix" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogPrefix">
            <summary>
            Add a prefix to all logs.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogPrefix">
            <summary>Gets whether the "log_prefix" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogPrefix">
            <summary>Clears the value of the "log_prefix" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogToStdoutFieldNumber">
            <summary>Field number for the "log_to_stdout" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogToStdout">
            <summary>
            Log to stdout.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogToStdout">
            <summary>Gets whether the "log_to_stdout" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogToStdout">
            <summary>Clears the value of the "log_to_stdout" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LogToResponseFieldNumber">
            <summary>Field number for the "log_to_response" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LogToResponse">
            <summary>
            Log to response proto.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLogToResponse">
            <summary>Gets whether the "log_to_response" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLogToResponse">
            <summary>Clears the value of the "log_to_response" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UsePbResolutionFieldNumber">
            <summary>Field number for the "use_pb_resolution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UsePbResolution">
            <summary>
            Whether to use pseudo-Boolean resolution to analyze a conflict. Note that
            this option only make sense if your problem is modelized using
            pseudo-Boolean constraints. If you only have clauses, this shouldn't change
            anything (except slow the solver down).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUsePbResolution">
            <summary>Gets whether the "use_pb_resolution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUsePbResolution">
            <summary>Clears the value of the "use_pb_resolution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MinimizeReductionDuringPbResolutionFieldNumber">
            <summary>Field number for the "minimize_reduction_during_pb_resolution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MinimizeReductionDuringPbResolution">
            <summary>
            A different algorithm during PB resolution. It minimizes the number of
            calls to ReduceCoefficients() which can be time consuming. However, the
            search space will be different and if the coefficients are large, this may
            lead to integer overflows that could otherwise be prevented.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMinimizeReductionDuringPbResolution">
            <summary>Gets whether the "minimize_reduction_during_pb_resolution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMinimizeReductionDuringPbResolution">
            <summary>Clears the value of the "minimize_reduction_during_pb_resolution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CountAssumptionLevelsInLbdFieldNumber">
            <summary>Field number for the "count_assumption_levels_in_lbd" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CountAssumptionLevelsInLbd">
             <summary>
             Whether or not the assumption levels are taken into account during the LBD
             computation. According to the reference below, not counting them improves
             the solver in some situation. Note that this only impact solves under
             assumptions.
            
             Gilles Audemard, Jean-Marie Lagniez, Laurent Simon, "Improving Glucose for
             Incremental SAT Solving with Assumptions: Application to MUS Extraction"
             Theory and Applications of Satisfiability Testing - SAT 2013, Lecture Notes
             in Computer Science Volume 7962, 2013, pp 309-317.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCountAssumptionLevelsInLbd">
            <summary>Gets whether the "count_assumption_levels_in_lbd" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCountAssumptionLevelsInLbd">
            <summary>Clears the value of the "count_assumption_levels_in_lbd" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveBveThresholdFieldNumber">
            <summary>Field number for the "presolve_bve_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveBveThreshold">
            <summary>
            During presolve, only try to perform the bounded variable elimination (BVE)
            of a variable x if the number of occurrences of x times the number of
            occurrences of not(x) is not greater than this parameter.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveBveThreshold">
            <summary>Gets whether the "presolve_bve_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveBveThreshold">
            <summary>Clears the value of the "presolve_bve_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveBveClauseWeightFieldNumber">
            <summary>Field number for the "presolve_bve_clause_weight" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveBveClauseWeight">
            <summary>
            During presolve, we apply BVE only if this weight times the number of
            clauses plus the number of clause literals is not increased.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveBveClauseWeight">
            <summary>Gets whether the "presolve_bve_clause_weight" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveBveClauseWeight">
            <summary>Clears the value of the "presolve_bve_clause_weight" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveProbingDeterministicTimeLimitFieldNumber">
            <summary>Field number for the "presolve_probing_deterministic_time_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveProbingDeterministicTimeLimit">
            <summary>
            The maximum "deterministic" time limit to spend in probing. A value of
            zero will disable the probing.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveProbingDeterministicTimeLimit">
            <summary>Gets whether the "presolve_probing_deterministic_time_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveProbingDeterministicTimeLimit">
            <summary>Clears the value of the "presolve_probing_deterministic_time_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveBlockedClauseFieldNumber">
            <summary>Field number for the "presolve_blocked_clause" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveBlockedClause">
            <summary>
            Whether we use an heuristic to detect some basic case of blocked clause
            in the SAT presolve.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveBlockedClause">
            <summary>Gets whether the "presolve_blocked_clause" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveBlockedClause">
            <summary>Clears the value of the "presolve_blocked_clause" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveUseBvaFieldNumber">
            <summary>Field number for the "presolve_use_bva" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveUseBva">
            <summary>
            Whether or not we use Bounded Variable Addition (BVA) in the presolve.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveUseBva">
            <summary>Gets whether the "presolve_use_bva" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveUseBva">
            <summary>Clears the value of the "presolve_use_bva" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveBvaThresholdFieldNumber">
            <summary>Field number for the "presolve_bva_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveBvaThreshold">
            <summary>
            Apply Bounded Variable Addition (BVA) if the number of clauses is reduced
            by stricly more than this threshold. The algorithm described in the paper
            uses 0, but quick experiments showed that 1 is a good value. It may not be
            worth it to add a new variable just to remove one clause.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveBvaThreshold">
            <summary>Gets whether the "presolve_bva_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveBvaThreshold">
            <summary>Clears the value of the "presolve_bva_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxPresolveIterationsFieldNumber">
            <summary>Field number for the "max_presolve_iterations" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxPresolveIterations">
            <summary>
            In case of large reduction in a presolve iteration, we perform multiple
            presolve iterations. This parameter controls the maximum number of such
            presolve iterations.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxPresolveIterations">
            <summary>Gets whether the "max_presolve_iterations" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxPresolveIterations">
            <summary>Clears the value of the "max_presolve_iterations" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CpModelPresolveFieldNumber">
            <summary>Field number for the "cp_model_presolve" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CpModelPresolve">
            <summary>
            Whether we presolve the cp_model before solving it.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCpModelPresolve">
            <summary>Gets whether the "cp_model_presolve" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCpModelPresolve">
            <summary>Clears the value of the "cp_model_presolve" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CpModelPostsolveWithFullSolverFieldNumber">
            <summary>Field number for the "cp_model_postsolve_with_full_solver" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CpModelPostsolveWithFullSolver">
            <summary>
            Advanced usage. We have two different postsolve code. The default one
            should be better and it allows for a more powerful presolve, but some
            rarely used features like not fully assigning all variables require the
            other one.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCpModelPostsolveWithFullSolver">
            <summary>Gets whether the "cp_model_postsolve_with_full_solver" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCpModelPostsolveWithFullSolver">
            <summary>Clears the value of the "cp_model_postsolve_with_full_solver" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CpModelMaxNumPresolveOperationsFieldNumber">
            <summary>Field number for the "cp_model_max_num_presolve_operations" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CpModelMaxNumPresolveOperations">
            <summary>
            If positive, try to stop just after that many presolve rules have been
            applied. This is mainly useful for debugging presolve.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCpModelMaxNumPresolveOperations">
            <summary>Gets whether the "cp_model_max_num_presolve_operations" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCpModelMaxNumPresolveOperations">
            <summary>Clears the value of the "cp_model_max_num_presolve_operations" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CpModelProbingLevelFieldNumber">
            <summary>Field number for the "cp_model_probing_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CpModelProbingLevel">
            <summary>
            How much effort do we spend on probing. 0 disables it completely.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCpModelProbingLevel">
            <summary>Gets whether the "cp_model_probing_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCpModelProbingLevel">
            <summary>Clears the value of the "cp_model_probing_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CpModelUseSatPresolveFieldNumber">
            <summary>Field number for the "cp_model_use_sat_presolve" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CpModelUseSatPresolve">
            <summary>
            Whether we also use the sat presolve when cp_model_presolve is true.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCpModelUseSatPresolve">
            <summary>Gets whether the "cp_model_use_sat_presolve" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCpModelUseSatPresolve">
            <summary>Clears the value of the "cp_model_use_sat_presolve" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseSatInprocessingFieldNumber">
            <summary>Field number for the "use_sat_inprocessing" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseSatInprocessing">
            <summary>Gets whether the "use_sat_inprocessing" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseSatInprocessing">
            <summary>Clears the value of the "use_sat_inprocessing" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExpandElementConstraintsFieldNumber">
            <summary>Field number for the "expand_element_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExpandElementConstraints">
            <summary>
            If true, the element constraints are expanded into many
            linear constraints of the form (index == i) => (element[i] == target).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExpandElementConstraints">
            <summary>Gets whether the "expand_element_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExpandElementConstraints">
            <summary>Clears the value of the "expand_element_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExpandAutomatonConstraintsFieldNumber">
            <summary>Field number for the "expand_automaton_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExpandAutomatonConstraints">
            <summary>
            If true, the automaton constraints are expanded.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExpandAutomatonConstraints">
            <summary>Gets whether the "expand_automaton_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExpandAutomatonConstraints">
            <summary>Clears the value of the "expand_automaton_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExpandTableConstraintsFieldNumber">
            <summary>Field number for the "expand_table_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExpandTableConstraints">
            <summary>
            If true, the positive table constraints are expanded.
            Note that currently, negative table constraints are always expanded.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExpandTableConstraints">
            <summary>Gets whether the "expand_table_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExpandTableConstraints">
            <summary>Clears the value of the "expand_table_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExpandAlldiffConstraintsFieldNumber">
            <summary>Field number for the "expand_alldiff_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExpandAlldiffConstraints">
            <summary>
            If true, expand all_different constraints that are not permutations.
            Permutations (#Variables = #Values) are always expanded.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExpandAlldiffConstraints">
            <summary>Gets whether the "expand_alldiff_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExpandAlldiffConstraints">
            <summary>Clears the value of the "expand_alldiff_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExpandReservoirConstraintsFieldNumber">
            <summary>Field number for the "expand_reservoir_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExpandReservoirConstraints">
            <summary>
            If true, expand the reservoir constraints by creating booleans for all
            possible precedences between event and encoding the constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExpandReservoirConstraints">
            <summary>Gets whether the "expand_reservoir_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExpandReservoirConstraints">
            <summary>Clears the value of the "expand_reservoir_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DisableConstraintExpansionFieldNumber">
            <summary>Field number for the "disable_constraint_expansion" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.DisableConstraintExpansion">
            <summary>
            If true, it disable all constraint expansion.
            This should only be used to test the presolve of expanded constraints.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDisableConstraintExpansion">
            <summary>Gets whether the "disable_constraint_expansion" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDisableConstraintExpansion">
            <summary>Clears the value of the "disable_constraint_expansion" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MergeNoOverlapWorkLimitFieldNumber">
            <summary>Field number for the "merge_no_overlap_work_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MergeNoOverlapWorkLimit">
            <summary>
            During presolve, we use a maximum clique heuristic to merge together
            no-overlap constraints or at most one constraints. This code can be slow,
            so we have a limit in place on the number of explored nodes in the
            underlying graph. The internal limit is an int64, but we use double here to
            simplify manual input.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMergeNoOverlapWorkLimit">
            <summary>Gets whether the "merge_no_overlap_work_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMergeNoOverlapWorkLimit">
            <summary>Clears the value of the "merge_no_overlap_work_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MergeAtMostOneWorkLimitFieldNumber">
            <summary>Field number for the "merge_at_most_one_work_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMergeAtMostOneWorkLimit">
            <summary>Gets whether the "merge_at_most_one_work_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMergeAtMostOneWorkLimit">
            <summary>Clears the value of the "merge_at_most_one_work_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveSubstitutionLevelFieldNumber">
            <summary>Field number for the "presolve_substitution_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveSubstitutionLevel">
            <summary>
            How much substitution (also called free variable aggregation in MIP
            litterature) should we perform at presolve. This currently only concerns
            variable appearing only in linear constraints. For now the value 0 turns it
            off and any positive value performs substitution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveSubstitutionLevel">
            <summary>Gets whether the "presolve_substitution_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveSubstitutionLevel">
            <summary>Clears the value of the "presolve_substitution_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PresolveExtractIntegerEnforcementFieldNumber">
            <summary>Field number for the "presolve_extract_integer_enforcement" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PresolveExtractIntegerEnforcement">
            <summary>
            If true, we will extract from linear constraints, enforcement literals of
            the form "integer variable at bound => simplified constraint". This should
            always be beneficial except that we don't always handle them as efficiently
            as we could for now. This causes problem on manna81.mps (LP relaxation not
            as tight it seems) and on neos-3354841-apure.mps.gz (too many literals
            created this way).
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPresolveExtractIntegerEnforcement">
            <summary>Gets whether the "presolve_extract_integer_enforcement" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPresolveExtractIntegerEnforcement">
            <summary>Clears the value of the "presolve_extract_integer_enforcement" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseOptimizationHintsFieldNumber">
            <summary>Field number for the "use_optimization_hints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseOptimizationHints">
            <summary>
            For an optimization problem, whether we follow some hints in order to find
            a better first solution. For a variable with hint, the solver will always
            try to follow the hint. It will revert to the variable_branching default
            otherwise.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseOptimizationHints">
            <summary>Gets whether the "use_optimization_hints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseOptimizationHints">
            <summary>Clears the value of the "use_optimization_hints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MinimizeCoreFieldNumber">
            <summary>Field number for the "minimize_core" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MinimizeCore">
            <summary>
            Whether we use a simple heuristic to try to minimize an UNSAT core.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMinimizeCore">
            <summary>Gets whether the "minimize_core" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMinimizeCore">
            <summary>Clears the value of the "minimize_core" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FindMultipleCoresFieldNumber">
            <summary>Field number for the "find_multiple_cores" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FindMultipleCores">
            <summary>
            Whether we try to find more independent cores for a given set of
            assumptions in the core based max-SAT algorithms.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFindMultipleCores">
            <summary>Gets whether the "find_multiple_cores" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFindMultipleCores">
            <summary>Clears the value of the "find_multiple_cores" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CoverOptimizationFieldNumber">
            <summary>Field number for the "cover_optimization" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CoverOptimization">
            <summary>
            If true, when the max-sat algo find a core, we compute the minimal number
            of literals in the core that needs to be true to have a feasible solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCoverOptimization">
            <summary>Gets whether the "cover_optimization" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCoverOptimization">
            <summary>Clears the value of the "cover_optimization" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxSatAssumptionOrderFieldNumber">
            <summary>Field number for the "max_sat_assumption_order" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxSatAssumptionOrder">
            <summary>Gets whether the "max_sat_assumption_order" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxSatAssumptionOrder">
            <summary>Clears the value of the "max_sat_assumption_order" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxSatReverseAssumptionOrderFieldNumber">
            <summary>Field number for the "max_sat_reverse_assumption_order" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxSatReverseAssumptionOrder">
            <summary>
            If true, adds the assumption in the reverse order of the one defined by
            max_sat_assumption_order.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxSatReverseAssumptionOrder">
            <summary>Gets whether the "max_sat_reverse_assumption_order" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxSatReverseAssumptionOrder">
            <summary>Clears the value of the "max_sat_reverse_assumption_order" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxSatStratificationFieldNumber">
            <summary>Field number for the "max_sat_stratification" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxSatStratification">
            <summary>Gets whether the "max_sat_stratification" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxSatStratification">
            <summary>Clears the value of the "max_sat_stratification" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UsePrecedencesInDisjunctiveConstraintFieldNumber">
            <summary>Field number for the "use_precedences_in_disjunctive_constraint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UsePrecedencesInDisjunctiveConstraint">
             <summary>
             When this is true, then a disjunctive constraint will try to use the
             precedence relations between time intervals to propagate their bounds
             further. For instance if task A and B are both before C and task A and B
             are in disjunction, then we can deduce that task C must start after
             duration(A) + duration(B) instead of simply max(duration(A), duration(B)),
             provided that the start time for all task was currently zero.
            
             This always result in better propagation, but it is usually slow, so
             depending on the problem, turning this off may lead to a faster solution.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUsePrecedencesInDisjunctiveConstraint">
            <summary>Gets whether the "use_precedences_in_disjunctive_constraint" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUsePrecedencesInDisjunctiveConstraint">
            <summary>Clears the value of the "use_precedences_in_disjunctive_constraint" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseOverloadCheckerInCumulativeConstraintFieldNumber">
            <summary>Field number for the "use_overload_checker_in_cumulative_constraint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseOverloadCheckerInCumulativeConstraint">
             <summary>
             When this is true, the cumulative constraint is reinforced with overload
             checking, i.e., an additional level of reasoning based on energy. This
             additional level supplements the default level of reasoning as well as
             timetable edge finding.
            
             This always result in better propagation, but it is usually slow, so
             depending on the problem, turning this off may lead to a faster solution.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseOverloadCheckerInCumulativeConstraint">
            <summary>Gets whether the "use_overload_checker_in_cumulative_constraint" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseOverloadCheckerInCumulativeConstraint">
            <summary>Clears the value of the "use_overload_checker_in_cumulative_constraint" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseTimetableEdgeFindingInCumulativeConstraintFieldNumber">
            <summary>Field number for the "use_timetable_edge_finding_in_cumulative_constraint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseTimetableEdgeFindingInCumulativeConstraint">
             <summary>
             When this is true, the cumulative constraint is reinforced with timetable
             edge finding, i.e., an additional level of reasoning based on the
             conjunction of energy and mandatory parts. This additional level
             supplements the default level of reasoning as well as overload_checker.
            
             This always result in better propagation, but it is usually slow, so
             depending on the problem, turning this off may lead to a faster solution.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseTimetableEdgeFindingInCumulativeConstraint">
            <summary>Gets whether the "use_timetable_edge_finding_in_cumulative_constraint" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseTimetableEdgeFindingInCumulativeConstraint">
            <summary>Clears the value of the "use_timetable_edge_finding_in_cumulative_constraint" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseDisjunctiveConstraintInCumulativeConstraintFieldNumber">
            <summary>Field number for the "use_disjunctive_constraint_in_cumulative_constraint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseDisjunctiveConstraintInCumulativeConstraint">
             <summary>
             When this is true, the cumulative constraint is reinforced with propagators
             from the disjunctive constraint to improve the inference on a set of tasks
             that are disjunctive at the root of the problem. This additional level
             supplements the default level of reasoning.
            
             Propagators of the cumulative constraint will not be used at all if all the
             tasks are disjunctive at root node.
            
             This always result in better propagation, but it is usually slow, so
             depending on the problem, turning this off may lead to a faster solution.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseDisjunctiveConstraintInCumulativeConstraint">
            <summary>Gets whether the "use_disjunctive_constraint_in_cumulative_constraint" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseDisjunctiveConstraintInCumulativeConstraint">
            <summary>Clears the value of the "use_disjunctive_constraint_in_cumulative_constraint" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LinearizationLevelFieldNumber">
            <summary>Field number for the "linearization_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.LinearizationLevel">
            <summary>
            A non-negative level indicating the type of constraints we consider in the
            LP relaxation. At level zero, no LP relaxation is used. At level 1, only
            the linear constraint and full encoding are added. At level 2, we also add
            all the Boolean constraints.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLinearizationLevel">
            <summary>Gets whether the "linearization_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLinearizationLevel">
            <summary>Clears the value of the "linearization_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BooleanEncodingLevelFieldNumber">
            <summary>Field number for the "boolean_encoding_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.BooleanEncodingLevel">
            <summary>
            A non-negative level indicating how much we should try to fully encode
            Integer variables as Boolean.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBooleanEncodingLevel">
            <summary>Gets whether the "boolean_encoding_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBooleanEncodingLevel">
            <summary>Clears the value of the "boolean_encoding_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxDomainSizeWhenEncodingEqNeqConstraintsFieldNumber">
            <summary>Field number for the "max_domain_size_when_encoding_eq_neq_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxDomainSizeWhenEncodingEqNeqConstraints">
            <summary>
            When loading a*x + b*y ==/!= c when x and y are both fully encoded.
            The solver may decide to replace the linear equation by a set of clauses.
            This is triggered if the sizes of the domains of x and y are below the
            threshold.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxDomainSizeWhenEncodingEqNeqConstraints">
            <summary>Gets whether the "max_domain_size_when_encoding_eq_neq_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxDomainSizeWhenEncodingEqNeqConstraints">
            <summary>Clears the value of the "max_domain_size_when_encoding_eq_neq_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxNumCutsFieldNumber">
            <summary>Field number for the "max_num_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxNumCuts">
             <summary>
             The limit on the number of cuts in our cut pool. When this is reached we do
             not generate cuts anymore.
            
             TODO(user): We should probably remove this parameters, and just always
             generate cuts but only keep the best n or something.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxNumCuts">
            <summary>Gets whether the "max_num_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxNumCuts">
            <summary>Clears the value of the "max_num_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.OnlyAddCutsAtLevelZeroFieldNumber">
            <summary>Field number for the "only_add_cuts_at_level_zero" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.OnlyAddCutsAtLevelZero">
            <summary>
            For the cut that can be generated at any level, this control if we only
            try to generate them at the root node.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasOnlyAddCutsAtLevelZero">
            <summary>Gets whether the "only_add_cuts_at_level_zero" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearOnlyAddCutsAtLevelZero">
            <summary>Clears the value of the "only_add_cuts_at_level_zero" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddKnapsackCutsFieldNumber">
            <summary>Field number for the "add_knapsack_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddKnapsackCuts">
            <summary>
            Whether we generate knapsack cuts. Note that in our setting where all
            variables are integer and bounded on both side, such a cut could be applied
            to any constraint.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddKnapsackCuts">
            <summary>Gets whether the "add_knapsack_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddKnapsackCuts">
            <summary>Clears the value of the "add_knapsack_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddCgCutsFieldNumber">
            <summary>Field number for the "add_cg_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddCgCuts">
            <summary>
            Whether we generate and add Chvatal-Gomory cuts to the LP at root node.
            Note that for now, this is not heavily tuned.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddCgCuts">
            <summary>Gets whether the "add_cg_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddCgCuts">
            <summary>Clears the value of the "add_cg_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddMirCutsFieldNumber">
            <summary>Field number for the "add_mir_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddMirCuts">
            <summary>
            Whether we generate MIR cuts at root node.
            Note that for now, this is not heavily tuned.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddMirCuts">
            <summary>Gets whether the "add_mir_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddMirCuts">
            <summary>Clears the value of the "add_mir_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddZeroHalfCutsFieldNumber">
            <summary>Field number for the "add_zero_half_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddZeroHalfCuts">
            <summary>
            Whether we generate Zero-Half cuts at root node.
            Note that for now, this is not heavily tuned.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddZeroHalfCuts">
            <summary>Gets whether the "add_zero_half_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddZeroHalfCuts">
            <summary>Clears the value of the "add_zero_half_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddCliqueCutsFieldNumber">
            <summary>Field number for the "add_clique_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddCliqueCuts">
            <summary>
            Whether we generate clique cuts from the binary implication graph. Note
            that as the search goes on, this graph will contains new binary clauses
            learned by the SAT engine.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddCliqueCuts">
            <summary>Gets whether the "add_clique_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddCliqueCuts">
            <summary>Clears the value of the "add_clique_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxAllDiffCutSizeFieldNumber">
            <summary>Field number for the "max_all_diff_cut_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxAllDiffCutSize">
            <summary>
            Cut generator for all diffs can add too many cuts for large all_diff
            constraints. This parameter restricts the large all_diff constraints to
            have a cut generator.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxAllDiffCutSize">
            <summary>Gets whether the "max_all_diff_cut_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxAllDiffCutSize">
            <summary>Clears the value of the "max_all_diff_cut_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddLinMaxCutsFieldNumber">
            <summary>Field number for the "add_lin_max_cuts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddLinMaxCuts">
            <summary>
            For the lin max constraints, generates the cuts described in "Strong
            mixed-integer programming formulations for trained neural networks" by Ross
            Anderson et. (https://arxiv.org/pdf/1811.01988.pdf)
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddLinMaxCuts">
            <summary>Gets whether the "add_lin_max_cuts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddLinMaxCuts">
            <summary>Clears the value of the "add_lin_max_cuts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxIntegerRoundingScalingFieldNumber">
            <summary>Field number for the "max_integer_rounding_scaling" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxIntegerRoundingScaling">
             <summary>
             In the integer rounding procedure used for MIR and Gomory cut, the maximum
             "scaling" we use (must be positive). The lower this is, the lower the
             integer coefficients of the cut will be. Note that cut generated by lower
             values are not necessarily worse than cut generated by larger value. There
             is no strict dominance relationship.
            
             Setting this to 2 result in the "strong fractional rouding" of Letchford
             and Lodi.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxIntegerRoundingScaling">
            <summary>Gets whether the "max_integer_rounding_scaling" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxIntegerRoundingScaling">
            <summary>Clears the value of the "max_integer_rounding_scaling" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AddLpConstraintsLazilyFieldNumber">
            <summary>Field number for the "add_lp_constraints_lazily" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AddLpConstraintsLazily">
            <summary>
            If true, we start by an empty LP, and only add constraints not satisfied
            by the current LP solution batch by batch. A constraint that is only added
            like this is known as a "lazy" constraint in the literature, except that we
            currently consider all constraints as lazy here.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAddLpConstraintsLazily">
            <summary>Gets whether the "add_lp_constraints_lazily" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAddLpConstraintsLazily">
            <summary>Clears the value of the "add_lp_constraints_lazily" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MinOrthogonalityForLpConstraintsFieldNumber">
            <summary>Field number for the "min_orthogonality_for_lp_constraints" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MinOrthogonalityForLpConstraints">
            <summary>
            While adding constraints, skip the constraints which have orthogonality
            less than 'min_orthogonality_for_lp_constraints' with already added
            constraints during current call. Orthogonality is defined as 1 -
            cosine(vector angle between constraints). A value of zero disable this
            feature.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMinOrthogonalityForLpConstraints">
            <summary>Gets whether the "min_orthogonality_for_lp_constraints" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMinOrthogonalityForLpConstraints">
            <summary>Clears the value of the "min_orthogonality_for_lp_constraints" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxCutRoundsAtLevelZeroFieldNumber">
            <summary>Field number for the "max_cut_rounds_at_level_zero" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxCutRoundsAtLevelZero">
            <summary>
            Max number of time we perform cut generation and resolve the LP at level 0.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxCutRoundsAtLevelZero">
            <summary>Gets whether the "max_cut_rounds_at_level_zero" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxCutRoundsAtLevelZero">
            <summary>Clears the value of the "max_cut_rounds_at_level_zero" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MaxConsecutiveInactiveCountFieldNumber">
            <summary>Field number for the "max_consecutive_inactive_count" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MaxConsecutiveInactiveCount">
            <summary>
            If a constraint/cut in LP is not active for that many consecutive OPTIMAL
            solves, remove it from the LP. Note that it might be added again later if
            it become violated by the current LP solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMaxConsecutiveInactiveCount">
            <summary>Gets whether the "max_consecutive_inactive_count" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMaxConsecutiveInactiveCount">
            <summary>Clears the value of the "max_consecutive_inactive_count" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CutMaxActiveCountValueFieldNumber">
            <summary>Field number for the "cut_max_active_count_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CutMaxActiveCountValue">
            <summary>
            These parameters are similar to sat clause management activity parameters.
            They are effective only if the number of generated cuts exceed the storage
            limit. Default values are based on a few experiments on miplib instances.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCutMaxActiveCountValue">
            <summary>Gets whether the "cut_max_active_count_value" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCutMaxActiveCountValue">
            <summary>Clears the value of the "cut_max_active_count_value" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CutActiveCountDecayFieldNumber">
            <summary>Field number for the "cut_active_count_decay" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCutActiveCountDecay">
            <summary>Gets whether the "cut_active_count_decay" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCutActiveCountDecay">
            <summary>Clears the value of the "cut_active_count_decay" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CutCleanupTargetFieldNumber">
            <summary>Field number for the "cut_cleanup_target" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CutCleanupTarget">
            <summary>
            Target number of constraints to remove during cleanup.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCutCleanupTarget">
            <summary>Gets whether the "cut_cleanup_target" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCutCleanupTarget">
            <summary>Clears the value of the "cut_cleanup_target" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NewConstraintsBatchSizeFieldNumber">
            <summary>Field number for the "new_constraints_batch_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.NewConstraintsBatchSize">
            <summary>
            Add that many lazy constraints (or cuts) at once in the LP. Note that at
            the beginning of the solve, we do add more than this.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNewConstraintsBatchSize">
            <summary>Gets whether the "new_constraints_batch_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNewConstraintsBatchSize">
            <summary>Clears the value of the "new_constraints_batch_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SearchBranchingFieldNumber">
            <summary>Field number for the "search_branching" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSearchBranching">
            <summary>Gets whether the "search_branching" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSearchBranching">
            <summary>Clears the value of the "search_branching" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.HintConflictLimitFieldNumber">
            <summary>Field number for the "hint_conflict_limit" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HintConflictLimit">
            <summary>
            Conflict limit used in the phase that exploit the solution hint.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasHintConflictLimit">
            <summary>Gets whether the "hint_conflict_limit" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearHintConflictLimit">
            <summary>Clears the value of the "hint_conflict_limit" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RepairHintFieldNumber">
            <summary>Field number for the "repair_hint" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RepairHint">
            <summary>
            If true, the solver tries to repair the solution given in the hint. This
            search terminates after the 'hint_conflict_limit' is reached and the solver
            switches to regular search. If false, then  we do a FIXED_SEARCH using the
            hint until the hint_conflict_limit is reached.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRepairHint">
            <summary>Gets whether the "repair_hint" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRepairHint">
            <summary>Clears the value of the "repair_hint" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FixVariablesToTheirHintedValueFieldNumber">
            <summary>Field number for the "fix_variables_to_their_hinted_value" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FixVariablesToTheirHintedValue">
            <summary>
            If true, variables appearing in the solution hints will be fixed to their
            hinted value.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFixVariablesToTheirHintedValue">
            <summary>Gets whether the "fix_variables_to_their_hinted_value" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFixVariablesToTheirHintedValue">
            <summary>Clears the value of the "fix_variables_to_their_hinted_value" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitIntegerLpSolutionFieldNumber">
            <summary>Field number for the "exploit_integer_lp_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitIntegerLpSolution">
            <summary>
            If true and the Lp relaxation of the problem has an integer optimal
            solution, try to exploit it. Note that since the LP relaxation may not
            contain all the constraints, such a solution is not necessarily a solution
            of the full problem.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitIntegerLpSolution">
            <summary>Gets whether the "exploit_integer_lp_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitIntegerLpSolution">
            <summary>Clears the value of the "exploit_integer_lp_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitAllLpSolutionFieldNumber">
            <summary>Field number for the "exploit_all_lp_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitAllLpSolution">
            <summary>
            If true and the Lp relaxation of the problem has a solution, try to exploit
            it. This is same as above except in this case the lp solution might not be
            an integer solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitAllLpSolution">
            <summary>Gets whether the "exploit_all_lp_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitAllLpSolution">
            <summary>Clears the value of the "exploit_all_lp_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitBestSolutionFieldNumber">
            <summary>Field number for the "exploit_best_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitBestSolution">
            <summary>
            When branching on a variable, follow the last best solution value.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitBestSolution">
            <summary>Gets whether the "exploit_best_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitBestSolution">
            <summary>Clears the value of the "exploit_best_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitRelaxationSolutionFieldNumber">
            <summary>Field number for the "exploit_relaxation_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitRelaxationSolution">
            <summary>
            When branching on a variable, follow the last best relaxation solution
            value. We use the relaxation with the tightest bound on the objective as
            the best relaxation solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitRelaxationSolution">
            <summary>Gets whether the "exploit_relaxation_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitRelaxationSolution">
            <summary>Clears the value of the "exploit_relaxation_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ExploitObjectiveFieldNumber">
            <summary>Field number for the "exploit_objective" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ExploitObjective">
            <summary>
            When branching an a variable that directly affect the objective,
            branch on the value that lead to the best objective first.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasExploitObjective">
            <summary>Gets whether the "exploit_objective" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearExploitObjective">
            <summary>Clears the value of the "exploit_objective" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ProbingPeriodAtRootFieldNumber">
            <summary>Field number for the "probing_period_at_root" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ProbingPeriodAtRoot">
            <summary>
            If set at zero (the default), it is disabled. Otherwise the solver attempts
            probing at every 'probing_period' root node. Period of 1 enables probing at
            every root node.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasProbingPeriodAtRoot">
            <summary>Gets whether the "probing_period_at_root" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearProbingPeriodAtRoot">
            <summary>Clears the value of the "probing_period_at_root" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseProbingSearchFieldNumber">
            <summary>Field number for the "use_probing_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseProbingSearch">
            <summary>
            If true, search will continuously probe Boolean variables, and integer
            variable bounds.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseProbingSearch">
            <summary>Gets whether the "use_probing_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseProbingSearch">
            <summary>Clears the value of the "use_probing_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PseudoCostReliabilityThresholdFieldNumber">
            <summary>Field number for the "pseudo_cost_reliability_threshold" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PseudoCostReliabilityThreshold">
            <summary>
            The solver ignores the pseudo costs of variables with number of recordings
            less than this threshold.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPseudoCostReliabilityThreshold">
            <summary>Gets whether the "pseudo_cost_reliability_threshold" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPseudoCostReliabilityThreshold">
            <summary>Clears the value of the "pseudo_cost_reliability_threshold" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.OptimizeWithCoreFieldNumber">
            <summary>Field number for the "optimize_with_core" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.OptimizeWithCore">
            <summary>
            The default optimization method is a simple "linear scan", each time trying
            to find a better solution than the previous one. If this is true, then we
            use a core-based approach (like in max-SAT) when we try to increase the
            lower bound instead.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasOptimizeWithCore">
            <summary>Gets whether the "optimize_with_core" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearOptimizeWithCore">
            <summary>Clears the value of the "optimize_with_core" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.OptimizeWithLbTreeSearchFieldNumber">
            <summary>Field number for the "optimize_with_lb_tree_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.OptimizeWithLbTreeSearch">
            <summary>
            Do a more conventional tree search (by opposition to SAT based one) where
            we keep all the explored node in a tree. This is meant to be used in a
            portfolio and focus on improving the objective lower bound. Keeping the
            whole tree allow us to report a better objective lower bound coming from
            the worst open node in the tree.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasOptimizeWithLbTreeSearch">
            <summary>Gets whether the "optimize_with_lb_tree_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearOptimizeWithLbTreeSearch">
            <summary>Clears the value of the "optimize_with_lb_tree_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.BinarySearchNumConflictsFieldNumber">
            <summary>Field number for the "binary_search_num_conflicts" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.BinarySearchNumConflicts">
            <summary>
            If non-negative, perform a binary search on the objective variable in order
            to find an [min, max] interval outside of which the solver proved unsat/sat
            under this amount of conflict. This can quickly reduce the objective domain
            on some problems.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasBinarySearchNumConflicts">
            <summary>Gets whether the "binary_search_num_conflicts" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearBinarySearchNumConflicts">
            <summary>Clears the value of the "binary_search_num_conflicts" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.OptimizeWithMaxHsFieldNumber">
            <summary>Field number for the "optimize_with_max_hs" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.OptimizeWithMaxHs">
            <summary>
            This has no effect if optimize_with_core is false. If true, use a different
            core-based algorithm similar to the max-HS algo for max-SAT. This is a
            hybrid MIP/CP approach and it uses a MIP solver in addition to the CP/SAT
            one. This is also related to the PhD work of tobyodavies@
            "Automatic Logic-Based Benders Decomposition with MiniZinc"
            http://aaai.org/ocs/index.php/AAAI/AAAI17/paper/view/14489
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasOptimizeWithMaxHs">
            <summary>Gets whether the "optimize_with_max_hs" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearOptimizeWithMaxHs">
            <summary>Clears the value of the "optimize_with_max_hs" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.EnumerateAllSolutionsFieldNumber">
            <summary>Field number for the "enumerate_all_solutions" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.EnumerateAllSolutions">
             <summary>
             Whether we enumerate all solutions of a problem without objective. Note
             that setting this to true automatically disable some presolve reduction
             that can remove feasible solution. That is it has the same effect as
             setting keep_all_feasible_solutions_in_presolve.
            
             TODO(user): Do not do that and let the user choose what behavior is best by
             setting keep_all_feasible_solutions_in_presolve ?
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasEnumerateAllSolutions">
            <summary>Gets whether the "enumerate_all_solutions" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearEnumerateAllSolutions">
            <summary>Clears the value of the "enumerate_all_solutions" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.KeepAllFeasibleSolutionsInPresolveFieldNumber">
            <summary>Field number for the "keep_all_feasible_solutions_in_presolve" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.KeepAllFeasibleSolutionsInPresolve">
             <summary>
             If true, we disable the presolve reductions that remove feasible solutions
             from the search space. Such solution are usually dominated by a "better"
             solution that is kept, but depending on the situation, we might want to
             keep all solutions.
            
             A trivial example is when a variable is unused. If this is true, then the
             presolve will not fix it to an arbitrary value and it will stay in the
             search space.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasKeepAllFeasibleSolutionsInPresolve">
            <summary>Gets whether the "keep_all_feasible_solutions_in_presolve" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearKeepAllFeasibleSolutionsInPresolve">
            <summary>Clears the value of the "keep_all_feasible_solutions_in_presolve" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FillTightenedDomainsInResponseFieldNumber">
            <summary>Field number for the "fill_tightened_domains_in_response" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.FillTightenedDomainsInResponse">
            <summary>
            If true, add information about the derived variable domains to the
            CpSolverResponse. It is an option because it makes the response slighly
            bigger and there is a bit more work involved during the postsolve to
            construct it, but it should still have a low overhead. See the
            tightened_variables field in CpSolverResponse for more details.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFillTightenedDomainsInResponse">
            <summary>Gets whether the "fill_tightened_domains_in_response" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFillTightenedDomainsInResponse">
            <summary>Clears the value of the "fill_tightened_domains_in_response" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InstantiateAllVariablesFieldNumber">
            <summary>Field number for the "instantiate_all_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InstantiateAllVariables">
            <summary>
            If true, the solver will add a default integer branching strategy to the
            already defined search strategy. If not, some variable might still not be
            fixed at the end of the search. For now we assume these variable can just
            be set to their lower bound.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInstantiateAllVariables">
            <summary>Gets whether the "instantiate_all_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInstantiateAllVariables">
            <summary>Clears the value of the "instantiate_all_variables" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.AutoDetectGreaterThanAtLeastOneOfFieldNumber">
            <summary>Field number for the "auto_detect_greater_than_at_least_one_of" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.AutoDetectGreaterThanAtLeastOneOf">
            <summary>
            If true, then the precedences propagator try to detect for each variable if
            it has a set of "optional incoming arc" for which at least one of them is
            present. This is usually useful to have but can be slow on model with a lot
            of precedence.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasAutoDetectGreaterThanAtLeastOneOf">
            <summary>Gets whether the "auto_detect_greater_than_at_least_one_of" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearAutoDetectGreaterThanAtLeastOneOf">
            <summary>Clears the value of the "auto_detect_greater_than_at_least_one_of" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.StopAfterFirstSolutionFieldNumber">
            <summary>Field number for the "stop_after_first_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.StopAfterFirstSolution">
            <summary>
            For an optimization problem, stop the solver as soon as we have a solution.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasStopAfterFirstSolution">
            <summary>Gets whether the "stop_after_first_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearStopAfterFirstSolution">
            <summary>Clears the value of the "stop_after_first_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.StopAfterPresolveFieldNumber">
            <summary>Field number for the "stop_after_presolve" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.StopAfterPresolve">
            <summary>
            Mainly used when improving the presolver. When true, stops the solver after
            the presolve is complete.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasStopAfterPresolve">
            <summary>Gets whether the "stop_after_presolve" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearStopAfterPresolve">
            <summary>Clears the value of the "stop_after_presolve" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.NumSearchWorkersFieldNumber">
            <summary>Field number for the "num_search_workers" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.NumSearchWorkers">
            <summary>
            Specify the number of parallel workers to use during search.
            A value of 0 means the solver will try to use all cores on the machine.
            A number of 1 means no parallelism.
            As of 2020-04-10, if you're using SAT via MPSolver (to solve integer
            programs) this field is overridden with a value of 8, if the field is not
            set *explicitly*. Thus, always set this field explicitly or via
            MPSolver::SetNumThreads().
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasNumSearchWorkers">
            <summary>Gets whether the "num_search_workers" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearNumSearchWorkers">
            <summary>Clears the value of the "num_search_workers" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InterleaveSearchFieldNumber">
            <summary>Field number for the "interleave_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.InterleaveSearch">
             <summary>
             Experimental. If this is true, then we interleave all our major search
             strategy and distribute the work amongst num_search_workers.
            
             The search is deterministic (independently of num_search_workers!), and we
             schedule and wait for interleave_batch_size task to be completed before
             synchronizing and scheduling the next batch of tasks.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInterleaveSearch">
            <summary>Gets whether the "interleave_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInterleaveSearch">
            <summary>Clears the value of the "interleave_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.InterleaveBatchSizeFieldNumber">
            <summary>Field number for the "interleave_batch_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasInterleaveBatchSize">
            <summary>Gets whether the "interleave_batch_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearInterleaveBatchSize">
            <summary>Clears the value of the "interleave_batch_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ReduceMemoryUsageInInterleaveModeFieldNumber">
            <summary>Field number for the "reduce_memory_usage_in_interleave_mode" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ReduceMemoryUsageInInterleaveMode">
            <summary>
            Temporary parameter until the memory usage is more optimized.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasReduceMemoryUsageInInterleaveMode">
            <summary>Gets whether the "reduce_memory_usage_in_interleave_mode" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearReduceMemoryUsageInInterleaveMode">
            <summary>Clears the value of the "reduce_memory_usage_in_interleave_mode" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ShareObjectiveBoundsFieldNumber">
            <summary>Field number for the "share_objective_bounds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ShareObjectiveBounds">
            <summary>
            Allows objective sharing between workers.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasShareObjectiveBounds">
            <summary>Gets whether the "share_objective_bounds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearShareObjectiveBounds">
            <summary>Clears the value of the "share_objective_bounds" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ShareLevelZeroBoundsFieldNumber">
            <summary>Field number for the "share_level_zero_bounds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ShareLevelZeroBounds">
            <summary>
            Allows sharing of the bounds of modified variables at level 0.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasShareLevelZeroBounds">
            <summary>Gets whether the "share_level_zero_bounds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearShareLevelZeroBounds">
            <summary>Clears the value of the "share_level_zero_bounds" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseLnsOnlyFieldNumber">
            <summary>Field number for the "use_lns_only" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseLnsOnly">
            <summary>
            LNS parameters.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseLnsOnly">
            <summary>Gets whether the "use_lns_only" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseLnsOnly">
            <summary>Clears the value of the "use_lns_only" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LnsFocusOnDecisionVariablesFieldNumber">
            <summary>Field number for the "lns_focus_on_decision_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLnsFocusOnDecisionVariables">
            <summary>Gets whether the "lns_focus_on_decision_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLnsFocusOnDecisionVariables">
            <summary>Clears the value of the "lns_focus_on_decision_variables" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.LnsExpandIntervalsInConstraintGraphFieldNumber">
            <summary>Field number for the "lns_expand_intervals_in_constraint_graph" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasLnsExpandIntervalsInConstraintGraph">
            <summary>Gets whether the "lns_expand_intervals_in_constraint_graph" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearLnsExpandIntervalsInConstraintGraph">
            <summary>Clears the value of the "lns_expand_intervals_in_constraint_graph" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SolutionPoolSizeFieldNumber">
            <summary>Field number for the "solution_pool_size" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SolutionPoolSize">
            <summary>
            Size of the top-n different solutions kept by the solver.
            Currently this only impact the "base" solution chosen for a LNS fragment.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSolutionPoolSize">
            <summary>Gets whether the "solution_pool_size" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSolutionPoolSize">
            <summary>Clears the value of the "solution_pool_size" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseRinsLnsFieldNumber">
            <summary>Field number for the "use_rins_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseRinsLns">
            <summary>
            Turns on relaxation induced neighborhood generator.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseRinsLns">
            <summary>Gets whether the "use_rins_lns" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseRinsLns">
            <summary>Clears the value of the "use_rins_lns" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseFeasibilityPumpFieldNumber">
            <summary>Field number for the "use_feasibility_pump" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseFeasibilityPump">
            <summary>
            Adds a feasibility pump subsolver along with lns subsolvers.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseFeasibilityPump">
            <summary>Gets whether the "use_feasibility_pump" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseFeasibilityPump">
            <summary>Clears the value of the "use_feasibility_pump" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.FpRoundingFieldNumber">
            <summary>Field number for the "fp_rounding" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasFpRounding">
            <summary>Gets whether the "fp_rounding" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearFpRounding">
            <summary>Clears the value of the "fp_rounding" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseRelaxationLnsFieldNumber">
            <summary>Field number for the "use_relaxation_lns" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseRelaxationLns">
            <summary>
            Turns on a lns worker which solves relaxed version of the original problem
            by removing constraints from the problem in order to get better bounds.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseRelaxationLns">
            <summary>Gets whether the "use_relaxation_lns" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseRelaxationLns">
            <summary>Clears the value of the "use_relaxation_lns" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.DiversifyLnsParamsFieldNumber">
            <summary>Field number for the "diversify_lns_params" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.DiversifyLnsParams">
            <summary>
            If true, registers more lns subsolvers with different parameters.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasDiversifyLnsParams">
            <summary>Gets whether the "diversify_lns_params" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearDiversifyLnsParams">
            <summary>Clears the value of the "diversify_lns_params" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.RandomizeSearchFieldNumber">
            <summary>Field number for the "randomize_search" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.RandomizeSearch">
            <summary>
            Randomize fixed search.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasRandomizeSearch">
            <summary>Gets whether the "randomize_search" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearRandomizeSearch">
            <summary>Clears the value of the "randomize_search" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SearchRandomizationToleranceFieldNumber">
            <summary>Field number for the "search_randomization_tolerance" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SearchRandomizationTolerance">
            <summary>
            Search randomization will collect equivalent 'max valued' variables, and
            pick one randomly. For instance, if the variable strategy is CHOOSE_FIRST,
            all unassigned variables are equivalent. If the variable strategy is
            CHOOSE_LOWEST_MIN, and `lm` is the current lowest min of all unassigned
            variables, then the set of max valued variables will be all unassigned
            variables where
               lm &lt;= variable min &lt;= lm + search_randomization_tolerance
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSearchRandomizationTolerance">
            <summary>Gets whether the "search_randomization_tolerance" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSearchRandomizationTolerance">
            <summary>Clears the value of the "search_randomization_tolerance" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseOptionalVariablesFieldNumber">
            <summary>Field number for the "use_optional_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseOptionalVariables">
            <summary>
            If true, we automatically detect variables whose constraint are always
            enforced by the same literal and we mark them as optional. This allows
            to propagate them as if they were present in some situation.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseOptionalVariables">
            <summary>Gets whether the "use_optional_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseOptionalVariables">
            <summary>Clears the value of the "use_optional_variables" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseExactLpReasonFieldNumber">
            <summary>Field number for the "use_exact_lp_reason" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseExactLpReason">
            <summary>
            The solver usually exploit the LP relaxation of a model. If this option is
            true, then whatever is infered by the LP will be used like an heuristic to
            compute EXACT propagation on the IP. So with this option, there is no
            numerical imprecision issues.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseExactLpReason">
            <summary>Gets whether the "use_exact_lp_reason" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseExactLpReason">
            <summary>Clears the value of the "use_exact_lp_reason" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseBranchingInLpFieldNumber">
            <summary>Field number for the "use_branching_in_lp" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseBranchingInLp">
            <summary>
            If true, the solver attemts to generate more info inside lp propagator by
            branching on some variables if certain criteria are met during the search
            tree exploration.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseBranchingInLp">
            <summary>Gets whether the "use_branching_in_lp" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseBranchingInLp">
            <summary>Clears the value of the "use_branching_in_lp" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseCombinedNoOverlapFieldNumber">
            <summary>Field number for the "use_combined_no_overlap" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseCombinedNoOverlap">
            <summary>
            This can be beneficial if there is a lot of no-overlap constraints but a
            relatively low number of different intervals in the problem. Like 1000
            intervals, but 1M intervals in the no-overlap constraints covering them.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseCombinedNoOverlap">
            <summary>Gets whether the "use_combined_no_overlap" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseCombinedNoOverlap">
            <summary>Clears the value of the "use_combined_no_overlap" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.CatchSigintSignalFieldNumber">
            <summary>Field number for the "catch_sigint_signal" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.CatchSigintSignal">
            <summary>
            Indicates if the CP-SAT layer should catch Control-C (SIGINT) signals
            when calling solve. If set, catching the SIGINT signal will terminate the
            search gracefully, as if a time limit was reached.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasCatchSigintSignal">
            <summary>Gets whether the "catch_sigint_signal" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearCatchSigintSignal">
            <summary>Clears the value of the "catch_sigint_signal" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.UseImpliedBoundsFieldNumber">
            <summary>Field number for the "use_implied_bounds" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.UseImpliedBounds">
            <summary>
            Stores and exploits "implied-bounds" in the solver. That is, relations of
            the form literal => (var >= bound). This is currently used to derive
            stronger cuts.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasUseImpliedBounds">
            <summary>Gets whether the "use_implied_bounds" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearUseImpliedBounds">
            <summary>Clears the value of the "use_implied_bounds" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.PolishLpSolutionFieldNumber">
            <summary>Field number for the "polish_lp_solution" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.PolishLpSolution">
            <summary>
            Whether we try to do a few degenerate iteration at the end of an LP solve
            to minimize the fractionality of the integer variable in the basis. This
            helps on some problems, but not so much on others. It also cost of bit of
            time to do such polish step.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasPolishLpSolution">
            <summary>Gets whether the "polish_lp_solution" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearPolishLpSolution">
            <summary>Clears the value of the "polish_lp_solution" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.ConvertIntervalsFieldNumber">
            <summary>Field number for the "convert_intervals" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.ConvertIntervals">
            <summary>
            Temporary flag util the feature is more mature. This convert intervals to
            the newer proto format that support affine start/var/end instead of just
            variables.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasConvertIntervals">
            <summary>Gets whether the "convert_intervals" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearConvertIntervals">
            <summary>Clears the value of the "convert_intervals" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.SymmetryLevelFieldNumber">
            <summary>Field number for the "symmetry_level" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.SymmetryLevel">
            <summary>
            Whether we try to automatically detect the symmetries in a model and
            exploit them. Currently, at level 1 we detect them in presolve and try
            to fix Booleans. At level 2, we also do some form of dynamic symmetry
            breaking during search.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasSymmetryLevel">
            <summary>Gets whether the "symmetry_level" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearSymmetryLevel">
            <summary>Clears the value of the "symmetry_level" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipMaxBoundFieldNumber">
            <summary>Field number for the "mip_max_bound" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipMaxBound">
            <summary>
            We need to bound the maximum magnitude of the variables for CP-SAT, and
            that is the bound we use. If the MIP model expect larger variable value in
            the solution, then the converted model will likely not be relevant.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipMaxBound">
            <summary>Gets whether the "mip_max_bound" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipMaxBound">
            <summary>Clears the value of the "mip_max_bound" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipVarScalingFieldNumber">
            <summary>Field number for the "mip_var_scaling" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipVarScaling">
            <summary>
            All continuous variable of the problem will be multiplied by this factor.
            By default, we don't do any variable scaling and rely on the MIP model to
            specify continuous variable domain with the wanted precision.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipVarScaling">
            <summary>Gets whether the "mip_var_scaling" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipVarScaling">
            <summary>Clears the value of the "mip_var_scaling" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipAutomaticallyScaleVariablesFieldNumber">
            <summary>Field number for the "mip_automatically_scale_variables" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipAutomaticallyScaleVariables">
            <summary>
            If true, some continuous variable might be automatically scaled. For now,
            this is only the case where we detect that a variable is actually an
            integer multiple of a constant. For instance, variables of the form k * 0.5
            are quite frequent, and if we detect this, we will scale such variable
            domain by 2 to make it implied integer.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipAutomaticallyScaleVariables">
            <summary>Gets whether the "mip_automatically_scale_variables" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipAutomaticallyScaleVariables">
            <summary>Clears the value of the "mip_automatically_scale_variables" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipWantedPrecisionFieldNumber">
            <summary>Field number for the "mip_wanted_precision" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipWantedPrecision">
             <summary>
             When scaling constraint with double coefficients to integer coefficients,
             we will multiply by a power of 2 and round the coefficients. We will choose
             the lowest power such that we have no potential overflow and the worst case
             constraint activity error do not exceed this threshold relative to the
             constraint bounds.
            
             We also use this to decide by how much we relax the constraint bounds so
             that we can have a feasible integer solution of constraints involving
             continuous variable. This is required for instance when you have an == rhs
             constraint as in many situation you cannot have a perfect equality with
             integer variables and coefficients.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipWantedPrecision">
            <summary>Gets whether the "mip_wanted_precision" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipWantedPrecision">
            <summary>Clears the value of the "mip_wanted_precision" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipMaxActivityExponentFieldNumber">
            <summary>Field number for the "mip_max_activity_exponent" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipMaxActivityExponent">
             <summary>
             To avoid integer overflow, we always force the maximum possible constraint
             activity (and objective value) according to the initial variable domain to
             be smaller than 2 to this given power. Because of this, we cannot always
             reach the "mip_wanted_precision" parameter above.
            
             This can go as high as 62, but some internal algo currently abort early if
             they might run into integer overflow, so it is better to keep it a bit
             lower than this.
             </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipMaxActivityExponent">
            <summary>Gets whether the "mip_max_activity_exponent" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipMaxActivityExponent">
            <summary>Clears the value of the "mip_max_activity_exponent" field</summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.MipCheckPrecisionFieldNumber">
            <summary>Field number for the "mip_check_precision" field.</summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.MipCheckPrecision">
            <summary>
            As explained in mip_precision and mip_max_activity_exponent, we cannot
            always reach the wanted precision during scaling. We use this threshold to
            enphasize in the logs when the precision seems bad.
            </summary>
        </member>
        <member name="P:Google.OrTools.Sat.SatParameters.HasMipCheckPrecision">
            <summary>Gets whether the "mip_check_precision" field is set</summary>
        </member>
        <member name="M:Google.OrTools.Sat.SatParameters.ClearMipCheckPrecision">
            <summary>Clears the value of the "mip_check_precision" field</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types">
            <summary>Container for nested types declared in the SatParameters message type.</summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.VariableOrder">
            <summary>
            Variables without activity (i.e. at the beginning of the search) will be
            tried in this preferred order.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.VariableOrder.InOrder">
            <summary>
            As specified by the problem.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.Polarity">
             <summary>
             Specifies the initial polarity (true/false) when the solver branches on a
             variable. This can be modified later by the user, or the phase saving
             heuristic.
            
             Note(user): POLARITY_FALSE is usually a good choice because of the
             "natural" way to express a linear boolean problem.
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.Polarity.WeightedSign">
            <summary>
            Choose the sign that tends to satisfy the most constraints. This is
            computed using a weighted sum: if a literal l appears in a constraint of
            the form: ... + coeff * l +... &lt;= rhs with positive coefficients and
            rhs, then -sign(l) * coeff / rhs is added to the weight of l.variable().
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.Polarity.ReverseWeightedSign">
            <summary>
            The opposite choice of POLARITY_WEIGHTED_SIGN.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.ConflictMinimizationAlgorithm">
            <summary>
            Do we try to minimize conflicts (greedily) when creating them.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.BinaryMinizationAlgorithm">
            <summary>
            Whether to expoit the binary clause to minimize learned clauses further.
            This will have an effect only if treat_binary_clauses_separately is true.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.ClauseProtection">
            <summary>
            Each time a clause activity is bumped, the clause has a chance to be
            protected during the next cleanup phase. Note that clauses used as a reason
            are always protected.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseProtection.ProtectionNone">
            <summary>
            No protection.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseProtection.ProtectionAlways">
            <summary>
            Protect all clauses whose activity is bumped.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseProtection.ProtectionLbd">
            <summary>
            Only protect clause with a better LBD.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.ClauseOrdering">
            <summary>
            The clauses that will be kept during a cleanup are the ones that come
            first under this order. We always keep or exclude ties together.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseOrdering.ClauseActivity">
            <summary>
            Order clause by decreasing activity, then by increasing LBD.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.ClauseOrdering.ClauseLbd">
            <summary>
            Order clause by increasing LBD, then by decreasing activity.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm">
             <summary>
             Restart algorithms.
            
             A reference for the more advanced ones is:
             Gilles Audemard, Laurent Simon, "Refining Restarts Strategies for SAT
             and UNSAT", Principles and Practice of Constraint Programming Lecture
             Notes in Computer Science 2012, pp 118-126
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm.LubyRestart">
            <summary>
            Just follow a Luby sequence times restart_period.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm.DlMovingAverageRestart">
            <summary>
            Moving average restart based on the decision level of conflicts.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm.LbdMovingAverageRestart">
            <summary>
            Moving average restart based on the LBD of conflicts.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.RestartAlgorithm.FixedRestart">
            <summary>
            Fixed period restart every restart period.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.MaxSatAssumptionOrder">
            <summary>
            In what order do we add the assumptions in a core-based max-sat algorithm
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.MaxSatStratificationAlgorithm">
            <summary>
            What stratification algorithm we use in the presence of weight.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.MaxSatStratificationAlgorithm.StratificationNone">
            <summary>
            No stratification of the problem.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.MaxSatStratificationAlgorithm.StratificationDescent">
            <summary>
            Start with literals with the highest weight, and when SAT, add the
            literals with the next highest weight and so on.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.MaxSatStratificationAlgorithm.StratificationAscent">
            <summary>
            Start with all literals. Each time a core is found with a given minimum
            weight, do not consider literals with a lower weight for the next core
            computation. If the subproblem is SAT, do like in STRATIFICATION_DESCENT
            and just add the literals with the next highest weight.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.SearchBranching">
            <summary>
            The search branching will be used to decide how to branch on unfixed nodes.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.AutomaticSearch">
            <summary>
            Try to fix all literals using the underlying SAT solver's heuristics,
            then generate and fix literals until integer variables are fixed.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.FixedSearch">
            <summary>
            If used then all decisions taken by the solver are made using a fixed
            order as specified in the API or in the CpModelProto search_strategy
            field.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.PortfolioSearch">
            <summary>
            If used, the solver will use various generic heuristics in turn.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.LpSearch">
             <summary>
             If used, the solver will use heuristics from the LP relaxation. This
             exploit the reduced costs of the variables in the relaxation.
            
             TODO(user): Maybe rename REDUCED_COST_SEARCH?
             </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.PseudoCostSearch">
            <summary>
            If used, the solver uses the pseudo costs for branching. Pseudo costs
            are computed using the historical change in objective bounds when some
            decision are taken.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.PortfolioWithQuickRestartSearch">
            <summary>
            Mainly exposed here for testing. This quickly tries a lot of randomized
            heuristics with a low conflict limit. It usually provides a good first
            solution.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.SearchBranching.HintSearch">
            <summary>
            Mainly used internally. This is like FIXED_SEARCH, except we follow the
            solution_hint field of the CpModelProto rather than using the information
            provided in the search_strategy.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod">
            <summary>
            Rounding method to use for feasibility pump.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod.NearestInteger">
            <summary>
            Rounds to the nearest integer value.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod.LockBased">
            <summary>
            Counts the number of linear constraints restricting the variable in the
            increasing values (up locks) and decreasing values (down locks). Rounds
            the variable in the direction of lesser locks.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod.ActiveLockBased">
            <summary>
            Similar to lock based rounding except this only considers locks of active
            constraints from the last lp solve.
            </summary>
        </member>
        <member name="F:Google.OrTools.Sat.SatParameters.Types.FPRoundingMethod.PropagationAssisted">
            <summary>
            This is expensive rounding algorithm. We round variables one by one and
            propagate the bounds in between. If none of the rounded values fall in
            the continuous domain specified by lower and upper bound, we use the
            current lower/upper bound (whichever one is closest) instead of rounding
            the fractional lp solution value. If both the rounded values are in the
            domain, we round to nearest integer.
            </summary>
        </member>
        <member name="T:Google.OrTools.Sat.CpModel">
            <summary>
             Wrapper class around the cp_model proto.
            </summary>
        </member>
        <member name="T:Google.OrTools.Util.Int64Vector.Int64VectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Util.Int64VectorVector.Int64VectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Util.IntVector.IntVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Util.IntVectorVector.IntVectorVectorEnumerator">
            Note that the IEnumerator documentation requires an InvalidOperationException to be thrown
            whenever the collection is modified. This has been done for changes in the size of the
            collection but not when one of the elements of the collection is modified as it is a bit
            tricky to detect unmanaged code that modifies the collection under our feet.
        </member>
        <member name="T:Google.OrTools.Util.OptionalBooleanReflection">
            <summary>Holder for reflection information generated from ortools/util/optional_boolean.proto</summary>
        </member>
        <member name="P:Google.OrTools.Util.OptionalBooleanReflection.Descriptor">
            <summary>File descriptor for ortools/util/optional_boolean.proto</summary>
        </member>
        <member name="T:Google.OrTools.Util.OptionalBoolean">
             <summary>
             A "three-way" boolean: unspecified, false or true.
            
             We don't use the value of 1 to increase the chance to catch bugs: eg. in
             python, a user may set a proto field of this type enum to a boolean value
             without type checks, if they set it to True, the proto validity code will
             catch it (because it'll be cast to 1, which is an invalid enum value).
             Note that if the user sets if to False (i.e. 0), it will be caught by the
             routing library's parameter validity check too.
             </summary>
        </member>
    </members>
</doc>
